<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[oracle常用的小sql]]></title>
    <url>%2F2019%2F07%2F16%2Foracle%E5%85%B3%E4%BA%8Esql%E7%9A%84%E5%B0%8F%E8%BF%90%E7%94%A8%2F</url>
    <content type="text"><![CDATA[oralce查询表中的字段、长度、注释、类型select COL.table_name,COL.COLUMN_NAME,COL.COMMENTS,TAB.data_type,TAB.data_length from user_col_comments col,USER_TAB_COLUMNS tab where 1=1 and COL.column_name = tab.column_name AND COL.TABLE_NAME = TAB.TABLE_NAME and COL.table_name = &apos;QYDJ_ZLJ&apos; 备注：“QYDJ_ZLJ”就是要查的表名称 查看、设置表空间自增长--查看默认用户及表空间 select USERNAME,DEFAULT_TABLESPACE,TEMPORARY_TABLESPACE from dba_users where username = &apos;QDJG&apos;; --查看表空间地址、用户、是否自增长 SELECT FILE_NAME,TABLESPACE_NAME,AUTOEXTENSIBLE FROM dba_data_files; --设置表空间自增长 ALTER DATABASE DATAFILE &apos;D:\ORACLEDATA\GXZHJG_DATA.DBF&apos; AUTOEXTEND ON; insrt和like/* * 返回子字符串在源字符串中的位置(字符串位置从1开始，而不是从0开始) * @param str 源字符串 * @param substr 子字符串 * @param position 检索位置，可省略(默认为1),参数为正时，从左向右检索，参数为负时，从右向左检索 * @param occurrence 检索子串出现次数(即子串在源串第几次出现)，可省略(默认为1),值只能为正整数，否则会报错 * @return 返回子字符串在源字符串中出现的位置（没找到返回0） */ instr(str, substr, position, occurrence); SELECT * FROM STUDENTTAB WHERE STUNAME LIKE &apos;%张%&apos;; 就相当于 SELECT * FROM STUDENTTAB WHERE INSTR(STUNAME, &apos;张&apos;) &gt; 0; SELECT * FROM STUDENTTAB WHERE STUNAME NOT LIKE &apos;%张%&apos;; 就相当于 SELECT * FROM STUDENTTAB WHERE INSTR(STUNAME, &apos;张&apos;) = 0; 总结 1. instr&gt;0 和like、instr=0 和not like 一般来说查询的结果相同(不考虑特殊字符) 2. instr是一个函数，可以建立函数索引，如果过滤的条件有索引，那么instr就可以提高性能。 3. like查询时，以&apos;%&apos;开头，列所加的索引是不起作用的。 4. 在没有索引的前提下，当数据量比较大时，instr要比like效率高。 DECODE 函数的运用DECODE函数的含义：decode(条件,值1,返回值1,值2,返回值2,…值n,返回值n,缺省值)这个是decode的表达式，具体的含义解释为： IF 条件=值1 THEN RETURN(翻译值1) ELSIF 条件=值2 THEN RETURN(翻译值2) ...... ELSIF 条件=值n THEN RETURN(翻译值n) ELSE RETURN(缺省值) END IF 判断type值并替换成汉字 select t.id, t.name,t.age,decode(t.sex, &apos;1&apos;, &apos;男生&apos;, &apos;2&apos;, &apos;女生&apos;, &apos;其他&apos;) as sex from STUDENT2 t CASE WHEN 的应用 简单case函数 CASE sex WHEN &apos;1&apos; THEN &apos;男&apos; WHEN &apos;2&apos; THEN &apos;女&apos; ELSE &apos;其他&apos; END 搜索case函数 CASE WHEN sex = &apos;1&apos; THEN &apos;男&apos; WHEN sex = &apos;2&apos; THEN &apos;女&apos; ELSE &apos;其他&apos; END 用一个sql语句完成不同条件的分组 SELECT 国家, SUM( CASE WHEN sex = &apos;1&apos; THEN 人口 ELSE 0 END), --男性人口 SUM( CASE WHEN sex = &apos;2&apos; THEN 人口 ELSE 0 END) --女性人口 FROM Table_A GROUP BY country; 批量更新数据库 update set from方法一： SQL&gt; update wwm2 2 set town=(select town from wwm5 where wwm5.id=wwm2.id) 3 where id=(select wwm5.id from wwm5 where wwm5.id=wwm2.id) 方法二： update table_name t1 set (a,b,c) = (select a,b,c from table_name_2 t2 where t1.a where exists(select 1 from table_name_2 t2 where t1.a=t2.a); ‐‐如果存在t1.a=t2.a，就更新，否则，不更新，所以不会导致t1表中所有的记录都被更新。 替换 replace函数select replace(replace(replace(&apos;2018-10-10 10:10:00&apos;,&apos; &apos;,&apos;&apos;),&apos;-&apos;,&apos;&apos;),&apos;:&apos;,&apos;&apos;) from dual; 批量插入数据库1. INSERT INTO ceshi2(name,age,gender) SELECT NAME,age,gender FROM ceshi; INSERT INTO ceshi2 SELECT NAME,age,gender FROM ceshi; ‐‐此时，我们如果略掉了目标表的列的话，则默认会对目标表的全部列进行数据插入，且SELECT后面的列的顺序 必须和目标表中的列的定义顺序完全一致 才能完成正确的数据插入，这是一个很容易被忽略的地方，值得注意。 2. INSERT INTO t1(field1,field2) VALUES(v101,v102),(v201,v202),(v301,v302),(v401,v402); 查看建表示时间SELECT CREATED FROM USER_OBJECTS WHERE OBJECT_NAME = &apos;表名&apos;; 创建视图CREATE OR REPLACE VIEW V_表名 AS SELECT 列名1，列名2，FROM 表名; 给新创建的视图授权查询权GRANT SELECT ON V_表名 TO 用户 创建索引CREATE INDEX 索引名 ON 表名(索引列); 清空数据1. TRUNCATE TABLE 表名 2. DELETE FROM 表名 ROWNUM用法SELECT * FROM (SELECT ROWNUM RN,R.* FROM RK_CKXX R WHERE ROWNUM &lt; 10) WHERE RN; ROWNUM在Mybatis中应该这样写 select * from ( select row_.*, rownum rownum_ from ( 语句。。。。。。。。。 &lt;![CDATA[ ) row_ where rownum &lt;= #{end} ) where rownum_ &gt; #{begin} ]]&gt;]]></content>
      <categories>
        <category>sql</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[根据文件头格式判断文件类型]]></title>
    <url>%2F2019%2F05%2F20%2F%E6%A0%B9%E6%8D%AE%E6%96%87%E4%BB%B6%E5%A4%B4%E6%A0%BC%E5%BC%8F%E5%88%A4%E6%96%AD%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[遇到的问题：一般情况下，我们判断上传文件格式就是判断文件的后缀名，但是正常的文件可以这样判断，假如一个文件是.txt格式的，有人故意把这个文件改为.mp4格式，这种情况下，你只判断后缀名就不行了。于是就有了判断文件头格式的方法。 解决办法：import java.io.File; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.IOException; import java.util.HashMap; import java.util.Iterator; import java.util.Map; public class FileTypeUtil { private final static Map&lt;String, String&gt; FILE_TYPE_MAP = new HashMap&lt;String, String&gt;(); // private static Logger log = (Logger) LogFactory.getLog(FileTypeUtil.class); private FileTypeUtil(){} static{ getAllFileType(); //初始化文件类型信息 } public static void main(String[] args) { FileTypeUtil.getFileType(); } private static void getAllFileType(){ FILE_TYPE_MAP.put(&quot;ffd8ffe000104a464946&quot;, &quot;jpg&quot;); //JPEG (jpg) FILE_TYPE_MAP.put(&quot;89504e470d0a1a0a0000&quot;, &quot;png&quot;); //PNG (png) FILE_TYPE_MAP.put(&quot;47494638396126026f01&quot;, &quot;gif&quot;); //GIF (gif) FILE_TYPE_MAP.put(&quot;49492a00227105008037&quot;, &quot;tif&quot;); //TIFF (tif) FILE_TYPE_MAP.put(&quot;424d228c010000000000&quot;, &quot;bmp&quot;); //16色位图(bmp) FILE_TYPE_MAP.put(&quot;424d8240090000000000&quot;, &quot;bmp&quot;); //24位位图(bmp) FILE_TYPE_MAP.put(&quot;424d8e1b030000000000&quot;, &quot;bmp&quot;); //256色位图(bmp) FILE_TYPE_MAP.put(&quot;41433130313500000000&quot;, &quot;dwg&quot;); //CAD (dwg) FILE_TYPE_MAP.put(&quot;3c21444f435459504520&quot;, &quot;html&quot;); //HTML (html) FILE_TYPE_MAP.put(&quot;3c21646f637479706520&quot;, &quot;htm&quot;); //HTM (htm) FILE_TYPE_MAP.put(&quot;48544d4c207b0d0a0942&quot;, &quot;css&quot;); //css FILE_TYPE_MAP.put(&quot;696b2e71623d696b2e71&quot;, &quot;js&quot;); //js FILE_TYPE_MAP.put(&quot;7b5c727466315c616e73&quot;, &quot;rtf&quot;); //Rich Text Format (rtf) FILE_TYPE_MAP.put(&quot;38425053000100000000&quot;, &quot;psd&quot;); //Photoshop (psd) FILE_TYPE_MAP.put(&quot;46726f6d3a203d3f6762&quot;, &quot;eml&quot;); //Email [Outlook Express 6] (eml) FILE_TYPE_MAP.put(&quot;d0cf11e0a1b11ae10000&quot;, &quot;doc&quot;); //MS Excel 注意：word、msi 和 excel的文件头一样 FILE_TYPE_MAP.put(&quot;d0cf11e0a1b11ae10000&quot;, &quot;vsd&quot;); //Visio 绘图 FILE_TYPE_MAP.put(&quot;5374616E64617264204A&quot;, &quot;mdb&quot;); //MS Access (mdb) FILE_TYPE_MAP.put(&quot;252150532D41646F6265&quot;, &quot;ps&quot;); FILE_TYPE_MAP.put(&quot;255044462d312e360d25&quot;, &quot;pdf&quot;); //Adobe Acrobat (pdf) FILE_TYPE_MAP.put(&quot;2e524d46000000120001&quot;, &quot;rmvb&quot;); //rmvb/rm相同 FILE_TYPE_MAP.put(&quot;464c5601050000000900&quot;, &quot;flv&quot;); //flv与f4v相同 FILE_TYPE_MAP.put(&quot;00000020667479706973&quot;, &quot;mp4&quot;); FILE_TYPE_MAP.put(&quot;49443303000000000f76&quot;, &quot;mp3&quot;); FILE_TYPE_MAP.put(&quot;000001ba210001000180&quot;, &quot;mpg&quot;); // FILE_TYPE_MAP.put(&quot;3026b2758e66cf11a6d9&quot;, &quot;wmv&quot;); //wmv与asf相同 FILE_TYPE_MAP.put(&quot;524946464694c9015741&quot;, &quot;wav&quot;); //Wave (wav) FILE_TYPE_MAP.put(&quot;52494646d07d60074156&quot;, &quot;avi&quot;); FILE_TYPE_MAP.put(&quot;4d546864000000060001&quot;, &quot;mid&quot;); //MIDI (mid) FILE_TYPE_MAP.put(&quot;504b0304140000000800&quot;, &quot;zip&quot;); FILE_TYPE_MAP.put(&quot;526172211a0700cf9073&quot;, &quot;rar&quot;); FILE_TYPE_MAP.put(&quot;235468697320636f6e66&quot;, &quot;ini&quot;); FILE_TYPE_MAP.put(&quot;504b03040a0000000000&quot;, &quot;jar&quot;); FILE_TYPE_MAP.put(&quot;4d5a9000030000000400&quot;, &quot;exe&quot;);//可执行文件 FILE_TYPE_MAP.put(&quot;3c25402070616765206c&quot;, &quot;jsp&quot;);//jsp文件 FILE_TYPE_MAP.put(&quot;4d616e69666573742d56&quot;, &quot;mf&quot;);//MF文件 FILE_TYPE_MAP.put(&quot;3c3f786d6c2076657273&quot;, &quot;xml&quot;);//xml文件 FILE_TYPE_MAP.put(&quot;efbbbf2f2a0d0a53514c&quot;, &quot;sql&quot;);//xml文件 FILE_TYPE_MAP.put(&quot;7061636b616765207765&quot;, &quot;java&quot;);//java文件 FILE_TYPE_MAP.put(&quot;406563686f206f66660d&quot;, &quot;bat&quot;);//bat文件 FILE_TYPE_MAP.put(&quot;1f8b0800000000000000&quot;, &quot;gz&quot;);//gz文件 FILE_TYPE_MAP.put(&quot;6c6f67346a2e726f6f74&quot;, &quot;properties&quot;);//bat文件 FILE_TYPE_MAP.put(&quot;cafebabe0000002e0041&quot;, &quot;class&quot;);//bat文件 FILE_TYPE_MAP.put(&quot;49545346030000006000&quot;, &quot;chm&quot;);//bat文件 FILE_TYPE_MAP.put(&quot;04000000010000001300&quot;, &quot;mxp&quot;);//bat文件 FILE_TYPE_MAP.put(&quot;504b0304140006000800&quot;, &quot;docx&quot;);//docx文件 FILE_TYPE_MAP.put(&quot;d0cf11e0a1b11ae10000&quot;, &quot;wps&quot;);//WPS文字wps、表格et、演示dps都是一样的 FILE_TYPE_MAP.put(&quot;6431303a637265617465&quot;, &quot;torrent&quot;); FILE_TYPE_MAP.put(&quot;494d4b48010100000200&quot;, &quot;264&quot;); FILE_TYPE_MAP.put(&quot;6D6F6F76&quot;, &quot;mov&quot;); //Quicktime (mov) FILE_TYPE_MAP.put(&quot;FF575043&quot;, &quot;wpd&quot;); //WordPerfect (wpd) FILE_TYPE_MAP.put(&quot;CFAD12FEC5FD746F&quot;, &quot;dbx&quot;); //Outlook Express (dbx) FILE_TYPE_MAP.put(&quot;2142444E&quot;, &quot;pst&quot;); //Outlook (pst) FILE_TYPE_MAP.put(&quot;AC9EBD8F&quot;, &quot;qdf&quot;); //Quicken (qdf) FILE_TYPE_MAP.put(&quot;E3828596&quot;, &quot;pwl&quot;); //Windows Password (pwl) FILE_TYPE_MAP.put(&quot;2E7261FD&quot;, &quot;ram&quot;); //Real Audio (ram) } /** * 得到上传文件的文件头 * @param src * @return */ private static String bytesToHexString(byte[] src){ StringBuilder stringBuilder = new StringBuilder(); if(null==src || src.length &lt;= 0){ return null; } for(int i = 0; i &lt; src.length; i++){ int v = src[i] &amp; 0xFF; String hv = Integer.toHexString(v); if(hv.length() &lt; 2){ stringBuilder.append(0); } stringBuilder.append(hv); } return stringBuilder.toString(); } /** * 获取文件类型 * @param file * @return */ public static String getFileType(){ String res = null; FileInputStream fis = null; try{ fis = new FileInputStream(&quot;C:\\Users\\lihao\\Desktop\\111.mp4&quot;); //获取文件头的前六位 byte[] b = new byte[5]; fis.read(b, 0, b.length); String fileCode = bytesToHexString(b); Iterator&lt;String&gt; keyIter = FILE_TYPE_MAP.keySet().iterator(); while(keyIter.hasNext()){ String key = keyIter.next(); //比较前几位是否相同就可以判断文件格式（相同格式文件文件头后面几位会有所变化） if(key.toLowerCase().startsWith(fileCode.toLowerCase()) || fileCode.toLowerCase().startsWith(key.toLowerCase())){ res = FILE_TYPE_MAP.get(key); break; } } System.out.println(&quot;文件头:&quot;+fileCode+&quot;-----文件类型:&quot;+res); fis.close(); }catch(FileNotFoundException e){ e.printStackTrace(); }catch (IOException e){ e.printStackTrace(); }finally { try { fis.close(); }catch (IOException e) { e.printStackTrace(); } } return res; } }]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>IO流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黎活明给程序员得忠告]]></title>
    <url>%2F2019%2F04%2F08%2F%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E5%BF%A0%E5%91%8A%2F</url>
    <content type="text"><![CDATA[展望未来，总结过去10年的程序员生涯，给程序员小弟弟小妹妹们的一些总结性忠告 走过的路，回忆起来是那么曲折，把自己的一些心得体会分享给程序员兄弟姐妹们，虽然时代在变化，但是很可能你也会走我已经做过的10年的路程，有些心得体会你可以借鉴一下，觉得说得有道理的你就接纳，觉得说得没道理的，你就抛弃，以下是我发自内心的，给大家的忠告，特别是针对那些小弟弟妹妹们。 自己的户口档案、养老保险、医疗保险、住房公积金一定要保管好。由于程序员行业每年跳槽一次，我不隐瞒大家，我至少换过5个以上的单位，这期间跳来跳去，甚至是城市都换过3个。还好户口没丢掉，其他都已经是乱了，好几个城市里，都有交过三金，甚至是一个程序的2个区里交的都有，那些东西，10年后，会变得很重要。你买房子若有公积金，可以取出来，贷款利率也会比较低一些，有孩子了，还需要上学，生病了还需要医疗保险。特别是买房子时，你要商业贷款与公积金贷款的利率差别还是很大，有可能会有10万的差距。你平时都注意这些，会给你带来的损失会最小，例如每个月缴纳300元的公积金，公司也缴纳300元，你一个月能存下来600元，一年就是7200元，10年就是72000元。我以前都忽视了这些，到我需要买房子时，公积金里可能只有几千元，10年很快就过去了，结果我没能存下来多少公积金，医疗保险，养老金等更别提了，都已经稀里糊涂了，这些损失10年累加起来，是很庞大的数字，大家要注意，跳槽换工作时也要保护好自身的利益，现在房价很贵，你可能是跟我一样，大山里出来打拼的娃子，家里也没有丰厚的积蓄，只有靠自己拼搏，买房子是人生的一件大事，等你到了10年，才想到这个事情，已经晚了，特别是孩子要上学，上幼儿园等，需要户口啥的都要齐全。 不要轻易换笔记本电脑，不要跟潮流，不要买过多的电子产品，不要过于频繁的更换手机。这方面我的经验教训也是惨痛的。我大概前后购买过5-6个笔记本，以前的都是1万多元一台，最近买的是一台是1万多给女朋友的，自己买了一台是7500元左右，手机大概换过接近10个了，这些钱加起来也足够有10万以上了，你可能一不小心就购买了这些电子产品，但是时间长了，你一回过头来想想，你为什么赚得也不少，但是为什么还是那么穷，是因为你购买这些电子产品花费了过多的金钱了，平时笔记本啥的贵重物品要保护好，我一个同事不小心丢了2台笔记本电脑，接近2万的损失啊，你净赚2万，不是那么容易的，这个窟窿不是开玩笑的，我曾经也被人偷了一个崭新的笔记本，损失1.5万左右，更糟糕的是最新的代码也丢被偷了。 这年代外语、学历、职称、驾驶证还是蛮重要的。想找高薪，外资企业是正确的选择，在同样的打工里，外资企业的收入普遍是高的，我就想不明白，我们的赚钱能力怎么就比不过人家了，社会不断发展，将来可能去外国就像串门一样了，也说不定的，外语好将来的就业机会也会更多更广一些。学历并不代表啥，但是学历也是敲门砖，例如有300个应聘者，那至少重点本科以下的，统统不看了，因为实在是来不及看了，你再厉害也被挡在机会的门外了，同样有时候你想改行什么的，职称也很重要，最起码评个中级职称，说不定还有机会能进入大学或者政府部门还是有可能性。若有充裕的时间，应该把驾驶证考了，因为你越到后面越忙与工作家庭，没机会学车了也说不定的，平时也别光顾拼命工作，工作10年后你才发现，原来身边的人都至少硕士学历了，你被社会自动淘汰了，我现在就有这个感觉，虽然我带过很多硕士，他们的就业机会比我还好，经常能进入名牌企业，我也一直进不去。 不要谈过多的女朋友，谈女朋友要看准，下手要稳准狠。我谈过2个女朋友，平均每个女朋友身上的开支前后大概会有10万左右，还好我不用谈第3个女朋友了，若投资失误，那也是很残忍的，谈女朋友也会消耗很多时间精力、还会消耗很多金钱，实话的讲的确是这样的，人家女孩子也值钱啊，凭什么就那么轻易的跟你啊，我跟第一个朋友分手时，我的生活至少是倒退了3-4年，一切从零开始，一切从头开始，我劝大家谈女朋友是人生最大的一笔买卖，投资失误会有惨痛的后果，不仅仅是金钱上的损失，更会有精神、心灵上的沉重打击，大家要学会珍惜女朋友，要学会哄好女朋友，让老婆开心每一天，虽然鱼儿上钩了，不用再下鱼饵了，偶尔也别忘记放点米，这个鱼要是脱钩了，那不是开玩笑的。 工作不要更换得太过于频繁，选好了行业方向最好别更换太频繁。换工作，换行业方向，就像熊掰苞米一样的道理，有时候是丢了芝麻捡西瓜，有时候是丢了西瓜捡芝麻，这个道理我就不多讲了，大家都应该能明白的。 要对身边的人好，要得到老板的信任、同事的认可及支持、珍惜良好的工作环境。有个朋友的QQ名字很有意思，“只爱陌生人”，陌生人是很有意思，但是最关键时刻，还是需要靠非陌生人，你每天跟同事一起生活，要维系好身边的人。你的成功与失败，往往是你身边的30-40个人决定的。你就是世界首富，他身边也是那么不超过100个人的在左右着他的生活，当你工作10年了，没一个老板信任你，没几个要好的同事朋友，那你惨了，你在这个世界上已经是很孤单了，你的收入，其实大多是来自这些身边的朋友给你介绍的生意，不大会网上掉几个馅饼的。现在你身边的人有可能在不久的将来，给你提供很多好机会。 钱很重要，但是生活质量比钱还重要，工作是很重要，但是家人比工作还重要。钱不是万能的，但是没钱是万万不能的。钱赚了，身体夸了，全送给医院了，钱赚了，身心疲惫了，人活着为了啥？不就为了开开心心生活嘛？工作重要，但是失去了家人的爱，失去了女朋友，失去了老婆孩子，那这个工作有啥用了？工作很容易就换了，家人是换不了的，老婆不是想换就换的，孩子不是想换就换的，连自己的家庭都不负责的人，怎么可能对公司负责呢？我一直是这个观念，来面试时觉得工作更重要的，我们一般不录取的，那太假了，或者太不懂事了。 工作累了，也别太贪玩，有时候还是需要多想想如何才能赚钱。时间一晃就过去了，工作累了是可以适当放松，但是别太贪玩，10年很容易就过去了，10年后你要买房子，要娶老婆，要买车子，要生娃娃，身体也会变得脆弱一些，需要良好的生活习惯，也经不起通宵了，通宵一次，你要低迷好几天才能缓过劲儿来，跟20刚出头完全不一样了，用钱的地方多了去了，父母也会变得更老一些，可能也需要你的照顾，整个家子都指望你赚钱，别到了这个时候，你才意识到赚钱是那么的重要，更何况现在城市的房价，动不动就是100万，加上按揭的利息，你很可能需要支付150万。还可能需要装修，买车子。可能你身上的压力是200万。别觉得谈钱就俗，你要学会赚钱，要有个需要赚钱的良好意识，当然你出身富裕家庭，就不用考虑这些因素了。 每天一点点进步，每月一点点积累，要敬业要爱业，我们给别人提供的也是服务。总有一天，你也会有累的时候，你也会有老的时候，这时候，你要靠啥呢？就要靠你平时的积累，你10年的积累，可以打倒很多竞争对手，他们再厉害，再怎么样，也很难抵得过你10年的积累，特别是后面5-10年的积累，成果会很明显，前面的1-5年，算是做软件的入门吧，除非你有高人指点，那可能2-3年就可以修成正果，软件在将来还是会值钱的，以为生活会越来越智能化，越来越数字化，软件的需求还是很有前途，最起码未来的10-20年里不用太担心失业问题了。 对程序员来讲，开发思想、架构、代码就是财富，别老丢弃你的劳动成果，要学会保护你的劳动成果。 我大概7-8年前的代码都在手上，经常改进来改进去，维护来维护去，在一定的程度上，让我生活轻松了不少，因为我不用什么都从头来过，我只要痛苦一次，以后就要反复重复利用，软件的价值在于重复利用，而不是每个东西，都从头开发，那永远也是辛苦的程序员，这个生活质量就别提了，不管自己的代码丑还是拿不出手，要学会精心维护，每天改进一点点，每个月一个小进步，每年一个大进步，多年的积累是宝贵的，这个早晚也会给你带来丰厚的收益。 当程序员要防止原地踏步，不是工作年限长了，经验就丰富了，能力就强了，年纪越大工作越难找。 我有一个朋友跟我开玩笑，工作5年的人，可能能力差距会很大，为什么呢？因为第一年他们干的事情都是一样的，都写程序了，2个人可能由于价值观不一样，5年后差距会很大，甚至是大到无法追赶的程度，为啥？因为还有机会的因素在里面，有的人干了5年，还是在原地踏步，天天只会写那些添加、删除、修改的代码。那你得注意了，需要不断的提高自己，才是硬道理。例如你会SQLServer，那要试着学习Oracle，你是做C/S的，那得需要提高到B/S的，你是做单机软件的，那得需要提高到网络软件，你只关注自己的工作的，需要学会管理，关心他人的工作。你是当程序员的，要试着提高当项目经理、部门经理，公司的总监等等，人有野心有目标才会不断进步，最俗的为了多赚钱，提高工作职位工作岗位，工作单位，也是可以理解的。年纪越大工作越难找，例如3-4千的工作是随便找找，玩一样，但是你30过后，最起码要找月薪上1万的工作，这样的工作是机会也少，一般小公司也给不起，还得找个好公司才可以，好公司又不是天天招聘人，天天缺好的工作岗位，说不好听点儿，小公司的老板才赚多少啊？他来钱也很不容易的，小池塘就不好容得下大鲨鱼了。 当创业的收入比打工还少时，那就别创业，要找比自己能力强的人创业，你不会吃亏。创业的收入，比打工还少，那就是瞎扯蛋，恶搞。创业的真正意思并不是要你去吃苦没钱赚，那是忽悠无知的人的。当你创业时的收入，比打工还多，那你可以考虑创业，没有工资什么的，股份啥的，都是瞎扯蛋。不要跟自己能力还弱的人一起创业，那损失最大的，很可能就是你，要创业，也要找比自己强的人一起创业，最起码赚不到钱，还能学到不少。不会有过多的损失。别热血一沸腾就创业了，创业了，也别烧自己的钱，家人的钱，那是很不抗烧的，没几下几十万就烧干了。其实打工，也是创业的开始，每个月都能拿到钱，还可以学到知识，什么公司的股份都是空话，没几个小公司能成功，开起来了也走不了3年就分家了，都忽悠小孩子玩的，除非真的有科技含量或者是客户资源的，否则股份是一文钱不值的，就算创业每个月也按时拿工资才是硬道理。 未来的生活节奏会更快，生活压力会更大，竞争会更激烈，社会服务体系会更完善。在未来，我们享受良好的服务的同时，也会为别人提供更良好的服务，需要在技能上还是服务质量上的要求会更高更严格。平时要注意提高自己，不要被时代淘汰掉，我从小的朋友，一波又一波被社会无情的淘汰了，很小的时候，我出生在大草原与大山的交界处，我小时候的玩伴，还在大山里，我跟着家人杀出来了，我小学、中学、大学、工作上的、这10年，我一直很坚强的拼搏下来，很不容易的在杭州立住脚了，说实话，参加工作后的十年，也是不断拼搏，不断提高的十年。]]></content>
      <categories>
        <category>软文</category>
      </categories>
      <tags>
        <tag>文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IO流（二）]]></title>
    <url>%2F2019%2F02%2F18%2FIO-2%2F</url>
    <content type="text"><![CDATA[本篇主要介绍字节流 java中字节流与字符流操作方式大致相同，连方法名都是类似的，只是在具体的实现上会有稍许差别 字节流的两个顶层类：InputStream输入流即读和OutputStream输出流即写 字节流的FileInputStream 此类是InputStream的子类，主要从文件中获取文件的输入字节 private static void function_demo2() throws IOException { // 创建字节文件读取流对象，使用了里氏替换原则，也可以把前面的InputStream is换成FileInputStream is; InputStream is = new FileInputStream(&quot;byte.txt&quot;); int ch;//存储读取到的字节数 while ((ch = is.read()) != -1) {//循环读取 System.out.println((char) ch);//输出到控制台 } is.close();//关闭流 } 数组缓冲的方式读取 private static void function_demo3() throws IOException { FileInputStream fs = new FileInputStream(&quot;D:/026/demo.txt&quot;);// 字节读取流对象 // 缓冲数组，注意此数组中的大小用的是读取流对象的availabel方法，此方法可获取需要被读取的文件的大小，但此方法在 // 读取大文件的时候不建议用，会把内容占满 byte[] by = new byte[fs.available()]; fs.read(by);// 因上面的字节数组的大小刚好为文件的大小，所以可调用read(byte[] b)方法把内容一次性读取到数组中去 System.out.println(new String(by)); fs.close(); } 字节流的FileOutputStream 此类实现了OutputStream，但是此类没有flush方法，若调用flush方法其实调的是其父类的。 private static void function_demo1() throws IOException { OutputStream os = new FileOutputStream(&quot;D:/026/demo1.txt&quot;);//字节写入流对象 os.write(new String(&quot;abc&quot;).getBytes()); os.flush(); os.close(); } 用字节流实现文件复制 private static void function_demo4() throws IOException { FileInputStream inputStream = new FileInputStream(&quot;D:/026/demo.txt&quot;);//字节读取流对象 FileOutputStream outputStream = new FileOutputStream(&quot;D:/026/demo2.txt&quot;);//字节写入流对象 byte[] bt = new byte[1024];//缓冲数组，每次读到的内容存放到此数组中 int ch;//每次读到的字节数 while ((ch = inputStream.read(bt)) != -1) {//如果读取了最后则read方法返回-1 outputStream.write(bt, 0, ch);//把读到的内容写入到新文件中 } outputStream.close();//关闭流 inputStream.close();//关闭流 } 用原始的字节流复制一个avi文件是非常慢的，因为它是一个字节一个字节的去读的。下面的例子是复制一个15M大小的文件，可以把程序运行起来后切到文件的目录明显的看到文件大小值的跳动，代码如下： private static void function_demo5() throws IOException { FileInputStream inputStream = new FileInputStream(&quot;1.avi&quot;);// 字节读取流对象 FileOutputStream outputStream = new FileOutputStream(&quot;2.avi&quot;);// 字节写入流对象 int ch; while ((ch = inputStream.read()) != -1) { outputStream.write(ch); outputStream.flush(); } outputStream.close(); inputStream.close(); } 高效的读取 private static void function_demo6() throws IOException { FileInputStream inputStream = new FileInputStream(&quot;1.avi&quot;); FileOutputStream outputStream = new FileOutputStream(&quot;3.avi&quot;); byte[] bt = new byte[inputStream.available()];//此方法创建数组的方式不建议用，若文件很大的话容易内存溢出 int ch; while ((ch = inputStream.read(bt)) != -1) { outputStream.write(bt, 0, ch); } outputStream.close(); inputStream.close(); } 读取键盘输入的字符，并转为大写输入到控制台，若输入了over则结束输入 private static void function_demo8() throws IOException { InputStream in = System.in; StringBuilder sb = new StringBuilder(); int ch; while ((ch = in.read()) != -1) { if (ch == &apos;\r&apos;) { continue; } if (ch == &apos;\n&apos;) { if (sb.toString().equals(&quot;over&quot;)) { break; } else { System.out.println(sb.toString().toUpperCase()); } sb.delete(0, sb.length()); } else { sb.append((char)ch); } } } 字节流和字符流的转换 InputStreamReader类是字节流通向字符流的桥梁，它属于字符流，继承自Reader；为了达到最高效率，可要考虑在 BufferedReader 内包装 InputStreamReader。 eg: BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); 如果用转换流实现：读取键盘输入的字符，并转为大写输入到控制台，若输入了over则结束输入 private static void function_demo9() throws IOException { InputStream inputStream = System.in; InputStreamReader reader = new InputStreamReader(inputStream); BufferedReader br = new BufferedReader(reader); String line = null; try { while ((line = br.readLine()) != null) { if (line.equals(&quot;over&quot;)) { break; } else { System.out.println(line.toUpperCase()); } } } catch (Exception e) { e.printStackTrace(); }finally { br.close(); } } 用转换流实现文件的读写 private static void function_demo10() throws IOException { InputStreamReader inputStreamReader = new InputStreamReader(new FileInputStream(&quot;demo.txt&quot;)); BufferedReader bufferedReader = new BufferedReader(inputStreamReader); OutputStreamWriter writer = new OutputStreamWriter(System.out); BufferedWriter bw = new BufferedWriter(writer); String line = null; try { while ((line = bufferedReader.readLine()) != null) { bw.write(line); bw.flush(); bw.newLine(); } } catch (Exception e) { e.printStackTrace(); } finally { bw.close(); bufferedReader.close(); } } IO流总结 字符流： 读 Reader FileReader 写 Writer FileWriter 高效的字符流： - 读 BufferedReader - 写 BufferedWriter 转换流 读 InputStreamReader 写 OutputStreamWriter 字节流 读 InputStream FileInputStream 写 OutputStream FileOutputStream 高效的字节流： 读 BufferedInputStream 写 BufferedOutputStream IO流有很多，体系很庞大，在用的时候难免会感觉无从下手，讲起来具体的某一个时说的天花乱坠，但具体个人去操作时不知所措。因此我们可以总结一下IO流的操作规律，明确几个操作点再用IO流的时候便会得心应手。 1，明确源和目的 源：InputStream Reader 目的：OutputStream Writer 2，明确是否纯文本数据 源：是纯文本 Reader 否 InputStream 目的：是纯文本 Writer 否 OutputStream 至此可明确具体用IO流中的哪个体系处理问题 3，明确具体设备 源设备： 硬盘：File 键盘：System 内存：数组 网络：Socket流 目的设备： 硬盘：File 键盘：System 内存：数组 网络：Socket流 4，是否需要其它功能 需要高效： 是：加上buffered 以下四个需求对应于四个明确 1，复制文本 a，明确源和目的 源：InputStream Reader 目的：OutputStream Writer b，是否是纯文本 是： 源：Reader 目的：Writer c，明确具体设备 源： 硬盘 File 目的： 硬盘 File 从而确定需要使用的IO体系为下： FileReader fr = new FileReader(“a.txt”); FileWriter fw = new FileWriter(“b.txt”); d，需要额外功能吗？ 是，需要高效 BufferedReader br = new BufferedReader(fr); BufferedWriter bw = new BufferedWriter(fw); 2，读取键盘录入信息，并写入到文本中 a，明确源和目的 源：InputStream Reader 目的：OutputStream Writer b，是否纯文本 是： 源：Reader 目的：Writer c，明确具体设备 源： 键盘 System 目的： 硬盘 File InputStream in = System.in; FileWriter fw=new FileWriter(“b.txt”); d，需要额外功能吗？ 读取的时候用的是字节流，写出的时候用的是字符流，所以操作起来不太方便，需要转换 InputStreamReader inReader=new InputStreamReader(System.in); 想高效 BufferedReader reader = new BufferedReader(new InputStreamReader(System.in)); BufferedWriter writer = new BufferedWriter(new FileWriter(“b.txt”)); 3，将一个文本数据显示在控制台上 a，明确源和目的 源：Reader InputStream 目的：Writer OutputStream b，是否是纯文本 是 源：Reader 目的：Writer c，明确具体设备 源：硬盘 FileReader 目的：控制台即内在 System FileReader reader=new FileReader(“a.txt”); OutputStream out=System.out; d：额外功能 转换并高效 BufferedReader br=new BufferedReader(reader); BufferedWriter bw=new BufferedWriter(new OutputStreamWriter(System.out)); 4，读取键盘录入的数据，显示在控制台上 a，明确源和目的 源：Reader InputStream 目的：Writer OutputStream b，是否是纯文本 是 Reader Writer c，明确具体设备 源：键盘 InputStream input=System.in； 目的：控制台 OutputStream out=System.out; d，额外功能 因为操作的都是字节流，但是却要用字符的形式输出，所以需要转换 InputStreamReader inputStream=new InputStreamReader(System.in); OutputStreamWriter outputStream=new OutputStreamWriter(System.out); 需要高效 BufferedReader br=new BufferedReader(new InputStreamReader(System.in)); BufferedWriter bw=new BufferedWriter(new OutputStreamWriter(System.out));]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>IO流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BootStarp动态展示表头]]></title>
    <url>%2F2018%2F12%2F24%2Fbootstarp%E5%8A%A8%E6%80%81%E5%B1%95%E7%A4%BA%E8%A1%A8%E5%A4%B4%2F</url>
    <content type="text"><![CDATA[BootStarp动态生成表头，生成数据 一般的bootStarp-table表格定义表头都是写死的，项目突然要用到动态生成表头，研究了一下，鼓捣出来了，小小的展示一下 html&lt;div&gt; &lt;table id=&quot;QueryTable&quot; data-mobile-responsive=&quot;true&quot;&gt;&lt;/table&gt; &lt;/div&gt; js$(document).ready(function () {初始化加载 initTable(); }); function initTable(){ $(&apos;#QueryTable&apos;).bootstrapTable(&apos;destroy&apos;); $(&quot;#QueryTable&quot;).bootstrapTable({ ajax : function (){ $.ajax({ type: &quot;GET&quot;, url: &apos;test/show?tm=&apos; + new Date().getTime(), async: true, data:{ id:id, Name:Name }, contentType: &quot;application/json;charset=utf-8&quot;, dataType :&apos;JSON&apos;, success: function (data) { var columns = []; for (var i=0;i&lt;data.columnnames.length;i++) { columns.push({ field: data.listcolumns[i],//属性值 align: &apos;center&apos;, title: data.columnnames[i]//表头字段 }); } var datajson=data.list//数据 $(&apos;#QueryTable&apos;).bootstrapTable(&apos;destroy&apos;).bootstrapTable({ toolbar: &apos;#toolbar&apos;, cache: false, striped: false, sidePagination: &quot;client&quot;, sortOrder: &quot;desc&quot;, pageSize: 10, pageNumber: 1, pageList: &quot;[10, 20, 50, 100]&quot;, showToggle: true, showColumns: true, exportDataType: &quot;basic&quot;, pagination: true, showRefresh: false, data: datajson,//数据赋值给data columns: columns//设置好的表头 }); }, error:function () { alert(&quot;无数据&quot;); } }) }, onLoadSuccess: function(){ //加载成功时执行 }, onClickRow:function(row, element) { }, }); } java代码@RequestMapping(value={&quot;/show&quot;}, produces={&quot;application/json;charset=utf-8&quot;}) @ResponseBody public Map&lt;String,List&lt;?&gt;&gt; orginalshow(HttpServletRequest request) throws Exception { String id = request.getParameter(&quot;id&quot;); Strign name = request.getParameter(&quot;name&quot;); ....... //经过一系列查询，得到数据，数据格式我解释 List listcolumnnames = new ArrayList();//存放表头的list List listcolumns = new ArrayList();//存放字段名的list List&lt;String&gt; total = new ArrayList&lt;&gt;();//数据量 List&lt;Map&gt; list = testService.selectByData(map);//存放数据的list 【备注：List&lt;Map&gt; 中存的key是字段名，value是数据。由于我这边查的是另一个数据库所以我用的是JDBC链接的数据库 List&lt;Map&gt; list = null; try { list = new ArrayList&lt;&gt;(); conn = DriverManager.getConnection(url, username, password); String sql = &quot;SELECT * from (SELECT a.*,ROWNUM rn FROM (select &quot; + columns + &quot; from &quot; + tableName + &quot;) a where ROWNUM &lt;= 10) where rn &gt;= 0&quot;; System.out.println(&quot;sql=&quot; + sql); ps = conn.prepareStatement(sql); rs = ps.executeQuery(); ResultSetMetaData rsd = rs.getMetaData();//得到数据集的结构，对这个结构有什么不懂的话可以看看我上一篇JDBC的博文（JDBC连接数据库的案例） while (rs.next()) { Map&lt;String, String&gt; map1 = new HashMap&lt;&gt;(); for (int i = 0; i &lt; rsd.getColumnCount(); i++) { String key = rsd.getColumnName(i + 1);//这个就是字段名 String value = rs.getString(i + 1);//这个就是数据集 map1.put(key, value); } list.add(map1); } return list; } catch (Exception e) { e.printStackTrace(); }finally { if (rs !=null) { rs.close(); } if (ps != null) { ps.close(); } if (conn !=null) { conn.close(); } }】 Map&lt;String,List&lt;?&gt;&gt; mapall = new HashMap&lt;&gt;(); mapall.put(&quot;columnnames&quot;,listcolumnnames); mapall.put(&quot;listcolumns&quot;,listcolumns); mapall.put(&quot;total&quot;,listtotal); mapall.put(&quot;list&quot;,list); return mapall;//这个map就是ajax执行成功后的data数据 }]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>bootstarp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC连接数据库的案例]]></title>
    <url>%2F2018%2F12%2F24%2Fjdbc%E9%93%BE%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[记一次修炼路上的JDBC链接数据库的案例import java.sql.*; static Connection conn = null; static PreparedStatement ps = null; static ResultSet rs = null; static { try { Class.forName(&quot;oracle.jdbc.driver.OracleDriver&quot;); } catch (ClassNotFoundException e) { e.printStackTrace(); } } List&lt;GaResField&gt; fieldList = (List&lt;GaResField&gt;) map.get(&quot;fieldList&quot;); String columns = &quot;&quot;;//得到所有的查询列 for (int i = 0; i &lt; fieldList.size(); i++) { GaResField gaResField = fieldList.get(i); columns += gaResField.getStname(); if (i != fieldList.size() - 1) { columns += &quot;,&quot;;//到最后一个就不加“，” } } List&lt;Map&gt; list = null; try { list = new ArrayList&lt;&gt;(); conn = DriverManager.getConnection(url, username, password); String sql = &quot;SELECT * from (SELECT a.*,ROWNUM rn FROM (select &quot; + columns + &quot; from &quot; + tableName + &quot;) a where ROWNUM &lt;= 10) where rn &gt;= 0&quot;; System.out.println(&quot;sql=&quot; + sql);//输出一下sql ps = conn.prepareStatement(sql); rs = ps.executeQuery();//得到结果集（rs必定不是空值） //如果想判断结果集不为空的话就【if(rs.next())】，注意这里rs.next()已经取出第一条数据判断了，下面的while（）循环中的rs.next()取出来的数据是第二条 ResultSetMetaData rsd = rs.getMetaData();//得到数据集的结构，可以取出字段数，字段名，表名。。。 while (rs.next()) {//rs.next();是得到第一条数据 Map&lt;String, String&gt; map1 = new HashMap&lt;&gt;(); for (int i = 0; i &lt; rsd.getColumnCount(); i++) { String key = rsd.getColumnName(i + 1);//取出字段名 String value = rs.getString(i + 1);//取出对应的值 map1.put(key, value); } list.add(map1); } return list; } catch (Exception e) { e.printStackTrace(); }finally {//一定要关闭数据库链接，不然很浪费资源 if (rs !=null) { rs.close(); } if (ps != null) { ps.close(); } if (conn !=null) { conn.close(); } }]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IO流（一）]]></title>
    <url>%2F2018%2F12%2F19%2FIO-1%2F</url>
    <content type="text"><![CDATA[IO流的分类 按照操作的对象不同可分为字节流与字符流 按照流的方向不同可分为输入（指从外部存储设备拿文件到内存）流也叫读与输出（指从内存把文件写入到外部存储设备）流也叫写 注：字节流可以操作任何类型的文件，字符流是后来才出现的，主要用来操作字符类的文件；字符流的出现源于编码表的问题，一开始计算机内使用ANSII编码，后来每种语言都有了自己的编码方式即编码表，为了统一这些编码信息国际标准化组织便产生了Unicode编码信息表来把世界各国的语言都包括在内，此编码表采用两个字节即16位来存储每一个字符，java内置的编码表便是Unicode编码；字符流是当读取文件的时候，以字节的形式读取后，查询编码表看具体使用哪种编码方式，查到以后再进行文件的输出，所以字符流是字节流+查编码表的封装形式。 流的顶层基类所有流的操作无非两种形式：读与写；所以Java便所这两种操作形式抽取出了字节流与字符流的两种顶层的基类 字节流的顶层基类：InputStream与OutputStream 字符流的顶层基类：Read与Write 代码部分import java.io.BufferedReader; import java.io.BufferedWriter; import java.io.FileReader; import java.io.FileWriter; import java.io.IOException; import java.io.LineNumberReader; public class FileTest { public static void main(String[] args) { try { function_demo7(); } catch (IOException e) { // TODO 自动生成的 catch 块 e.printStackTrace(); } } /** * 字符流FileWite */ public static void function_demo1() throws IOException { // 创建字符写入流对象，接收一个要写入的文件路径对象，此文件若不存在则新创建一个文件，若已存在则覆盖的文件 FileWriter fw = new FileWriter(&quot;C:\\Users\\lihao\\Desktop\\file\\demo1.txt&quot;); fw.write(&quot;abcdefg&quot;);// 把内容写入缓冲区 fw.flush();// 从缓冲区把内容刷入文件中 fw.close();// 关闭流 //注：以上代码中fw.flush()是把内容从缓冲区刷入到文件中去， //但是fw.close()方法是先把内容从缓冲区刷入到文件中去即先调用flush方法，所以fw.flush()可以不用 } /** * FileWite换行和续写 */ // 获取系统换行的符号 private static final String LINE_SEPARATOR = System.getProperty(&quot;line.separator&quot;); public static void function_demo2() throws IOException { FileWriter writer = new FileWriter(&quot;C:\\Users\\lihao\\Desktop\\file\\demo2.txt&quot;, true);// 创建写入流对象 // 把内容写入到缓冲区 writer.write(&quot;abcdef绵&quot; + LINE_SEPARATOR + &quot;中国人啊啊啊啊啊啊啊&quot;); // 把缓冲区里的内容刷入到文件系统中 // writer.flush(); // 关闭流，在关闭之前会先把缓冲区里的内容刷入到文件系统然后才关闭流；若用此关闭流可不用手动调用flush writer.close(); //注：FileWriter在支持续写的时候提供了一个带两个参数的构造函数，当传递为true时即可支持续写；换行可调用系统提供的换行符号 } /** * 字符流FileReader */ public static void function_demo3() throws IOException { // 创建读取流对象，指定需要读取的文件地址 FileReader reader = new FileReader(&quot;C:\\Users\\lihao\\Desktop\\file\\demo2.txt&quot;); // 声明一个变量接收读取到的字符 int ch; // 调用read方法读取文件中的字符，当读取到文件的末尾的时候read方法返回-1 while ((ch = reader.read()) != -1) { System.out.println((char) ch); } // 关闭流 reader.close(); //注：此读取方式为一个字符的读取，每读取一个字符便写到控制台， //以下代码演示高效的读取，即声明一个缓冲区的数组，把每次所读到的内容先放入缓冲数组中去，然后再一次性写到文件中 } public static void function_demo4() throws IOException { //读取流对象 FileReader reader = new FileReader(&quot;C:\\Users\\lihao\\Desktop\\file\\demo2.txt&quot;); //每次读取到的字符放入的缓冲数组区 char[] buf = new char[1024]; //每次读取到的字符数 int i; //循环读取，每次read一次把读取到的内容放入buf字符数组，读到最后会返回-1 while ((i = reader.read(buf)) != -1) { //把读取到的字符转为字符串，每次转换的数量为读取到的字符数 System.out.println(new String(buf, 0, i)); } reader.close(); } /** * 下面用两种方式实现文件的复制功能 */ private static void function_demo5() throws IOException { FileReader fr = new FileReader(&quot;C:\\Users\\lihao\\Desktop\\file\\demo1.txt&quot;);//创建读取流对象 FileWriter fw = new FileWriter(&quot;C:\\Users\\lihao\\Desktop\\file\\demo2.txt&quot;);//创建写入流对象，若文件不存在则创建；若存在则覆盖 int ch;//存储读取到的字符 //循环读取文件中的数据 while ((ch = fr.read()) != -1) { fw.write(ch);//把每次读到的内容写入到新文件中 } fw.close();//关闭 fr.close();//关闭 } /** * 高效的文件复制 */ private static void function_demo6() throws IOException { FileReader fr = new FileReader(&quot;C:\\Users\\lihao\\Desktop\\file\\demo1.txt&quot;);// 创建读取流对象 FileWriter fw = new FileWriter(&quot;C:\\Users\\lihao\\Desktop\\file\\demo2.txt&quot;);// 创建写入流对象，若文件不存在则创建，若存在则覆盖 char[] buf = new char[4096];//缓存数组 int ch;// 存储读取到的字符 // 循环读取文件中的数据 while ((ch = fr.read(buf)) != -1) {//把每次读取到的内容放入缓存数组中 fw.write(buf, 0, ch);//从缓存数组中把内容读出来 } fw.close();//关闭流 fr.close();//关闭流 } /** * 高效的读取流BufferReader * 从字符输入流中读取文本，缓冲各个字符，从而实现字符、数组和行的高效读取。 * 注意，此类可以直接读取行，由此也说明此类是专门为高效的读取文件数据的方式 */ private static void function_demo7() throws IOException { FileReader fr = new FileReader(&quot;C:\\Users\\lihao\\Desktop\\file\\demo2.txt&quot;);//读取流对象 BufferedReader bReader = new BufferedReader(fr);//缓冲读取流对象，需要传入读取Reader的实现类 int ch; while ((ch = bReader.read()) != -1) {//此read为增强了的read方法，用的装饰器模式 System.out.println((char) ch); } bReader.close();//关闭该流并释放与之关联的所有资源；即也把读取流的对象fr给关闭了，不需要再手动调用fr.close() } /** * 带缓冲数组的读取 */ private static void function_demo8() throws IOException { FileReader fr = new FileReader(&quot;demo.txt&quot;);// 读取流对象 BufferedReader bReader = new BufferedReader(fr);// 缓冲读取流对象，需要传入读取Reader的实现类 int ch = 0; char[] buff = new char[1024]; while ((ch = bReader.read(buff)) != -1) {// 此read为增强了的read方法，用的装饰器模式 System.out.println(new String(buff, 0, ch)); } bReader.close();// 关闭该流并释放与之关联的所有资源；即也把读取流的对象fr给关闭了，不需要再手动调用fr.close() } /** * 读取行 * @throws IOException */ private static void function_demo9() throws IOException { FileReader fr = new FileReader(&quot;demo.txt&quot;); BufferedReader bReader = new BufferedReader(fr); String line = null;//获取每次读到的行内容 while ((line = bReader.readLine()) != null) {//如果读取到了最后，则返回null System.out.println(line); } bReader.close(); } /** * 高效的写入流BufferedWriter * 将文本写入字符输出流，缓冲各个字符，从而提供单个字符、数组和字符串的高效写入。此流写入的时候提供了一个newLine方法，可换行。 */ private static void function_demo10() throws IOException { FileWriter fw = new FileWriter(&quot;demo4.txt&quot;); BufferedWriter bw = new BufferedWriter(fw); bw.write(&quot;LioneTree&quot;); bw.newLine(); bw.write(&quot;go kb go kb nnw huo kb &quot;); bw.close(); } /** * 使用BufferedReader与BufferedWriter实现文件复制的功能 */ private static void function_demo11() throws IOException { FileReader fReader = new FileReader(&quot;demo.txt&quot;);//读取流对象 BufferedReader bReader = new BufferedReader(fReader);//缓冲读取流对象，传入fReader读取流对象 FileWriter fWriter = new FileWriter(&quot;demo5.txt&quot;);//写入流对象 BufferedWriter bWriter = new BufferedWriter(fWriter);//缓冲写入流对象，传入bWriter写入流对象 String line=null;//存储每次读取到的行内容 while((line=bReader.readLine())!=null) {//如果文件内容读完了则返回null bWriter.write(line);//写入读取到的每行内容 bWriter.newLine();//每读完一行则换行 } bReader.close();//关闭读取流对象 bWriter.close();//关闭写入流对象 } /** * 跟踪行号的缓冲字符输入流LineNumberReader * 此类定义了方法 setLineNumber(int) 和 getLineNumber()，它们可分别用于设置和获取当前行号；字继承自BufferedReader类 */ private static void function_demo12() throws IOException { FileReader fr = new FileReader(&quot;demo.txt&quot;);// 读取流对象 LineNumberReader lnr = new LineNumberReader(fr);// 行号读取流对象，需要传入读取流fr对象 String line = null;// 存储读取到的内容 lnr.setLineNumber(100);// 设置起始行号，若不设置默认从0开始，在读取到的每一行的末尾处自增1 while ((line = lnr.readLine()) != null) {// 按行读取 System.out.println(lnr.getLineNumber() + &quot; &quot; + line); } lnr.close(); } }]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>IO流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[input下拉tree树（zTree插件）]]></title>
    <url>%2F2018%2F12%2F11%2Finput-zTree%2F</url>
    <content type="text"><![CDATA[这次做项目还用到了另一个tree树的插件，就是input输入框下拉tree树 我这只是简单的下拉显示tree树，没有tree树的添加、编辑、删除、移动等操作先看图片 zTree官方API文档http://www.treejs.cn/v3/api.php 上代码 引入的js &lt;script src=&quot;js/jquery-1.4.4.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;link href=&quot;css/zTreeStyle/zTreeStyle.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; &lt;script src=&quot;js/jquery.ztree.core-3.5.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/jquery.ztree.excheck-3.5.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; js文件包括源码上传至百度云：https://pan.baidu.com/s/1iOtplePD1gwYBme8y4BD4w 代码 &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; &gt; &lt;head runat=&quot;server&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;!-- for HTML5 --&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;script src=&quot;js/jquery-1.4.4.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;link href=&quot;css/zTreeStyle/zTreeStyle.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; &lt;script src=&quot;js/jquery.ztree.core-3.5.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/jquery.ztree.excheck-3.5.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var setting = { view: { showIcon: false//设置 zTree 是否显示节点的图标。默认值：true showLine: false//设置 zTree 是否显示节点之间的连线。默认值：true }, data: { simpleData: { enable: true//确定 zTree 初始化时的节点数据、异步加载时的节点数据、或 addNodes 方法中输入的 newNodes 数据是否采用简单数据模式 (Array) 不需要用户再把数据库中取出的 List 强行转换为复杂的 JSON 嵌套格式 默认值：false ztree有两种数据格式1、标准数据格式 2、简单数据格式（我们常用的json数据格式，也就是我下面的数据格式） idKey: &quot;id&quot;,//你后台返回的json的id字段（节点数据中保存唯一标识的属性名称。[setting.data.simpleData.enable = true 时生效]） pIdKey: &quot;pId&quot;,//你后台返回的json的父级id字段（节点数据中保存其父节点唯一标识的属性名称。[setting.data.simpleData.enable = true 时生效]） rootPId: 0（用于修正根节点父节点数据，即 pIdKey 指定的属性值。[setting.data.simpleData.enable = true 时生效]） } }, callback: { onClick: onClick//用于捕获节点被点击的事件回调函数 //如果设置了 setting.callback.beforeClick 方法，且返回 false，将无法触发 onClick 事件回调函数。 } }; var filename; var parentids; var parentId; function onClick(e, treeId, treeNode) { $(&apos;#txtTreeSelect&apos;).val(treeNode.name); alert(treeNode.tId + &quot;, &quot; + treeNode.name);//每次点击节点后， 弹出该节点的 Id、name 的信息 filename = getFilePath(treeNode);//获取所有父节点的名字 parentids = getFileId(treeNode);//获取所有父节点的id parentId = treeNode.id;//获取点击节点的id } //获取所有父节点名字 function getFilePath(treeObj){ if(treeObj==null)return &quot;&quot;; var filename = treeObj.name; var pNode = treeObj.getParentNode(); if(pNode!=null){ filename = getFilePath(pNode) +&quot;&gt;&quot;+ filename; } return filename; } //获取所有父节点id function getFileId(treeObj){ if(treeObj==null)return &quot;&quot;; var id = treeObj.id; var pNode = treeObj.getParentNode(); if(pNode!=null){ id = getFileId(pNode) +&quot;&gt;&quot;+ id; } return id; } function showMenu() {//输入框的点击事件 var cityObj = $(&apos;#txtTreeSelect&apos;); var cityOffset = cityObj.offset(); $(&quot;#menuContent&quot;).css({ left: cityOffset.left + &quot;px&quot;, top: cityOffset.top + cityObj.outerHeight() + &quot;px&quot; }).slideDown(&quot;fast&quot;); $(&quot;body&quot;).bind(&quot;mousedown&quot;, onBodyDown); } function hideMenu() {//初始化隐藏下拉树 $(&quot;#menuContent&quot;).fadeOut(&quot;fast&quot;); $(&quot;body&quot;).unbind(&quot;mousedown&quot;, onBodyDown); } function onBodyDown(event) {//树的主体 if (!(event.target.id == &quot;menuBtn&quot; || event.target.id == &quot;menuContent&quot; || $(event.target).parents(&quot;#menuContent&quot;).length &gt; 0)) { hideMenu(); } } $(document).ready(function () {//一进页面就会加载的方法 var zNodes =[//自定义json { id:1, pId:0, name:&quot;父节点1 - 展开&quot;, open:true,url:&quot;jyy&quot;}, { id:11, pId:1, name:&quot;父节点11 - 折叠&quot;}, { id:111, pId:11, name:&quot;叶子节点111&quot;}, { id:112, pId:11, name:&quot;叶子节点112&quot;}, { id:113, pId:11, name:&quot;叶子节点113&quot;}, { id:114, pId:11, name:&quot;叶子节点114&quot;}, { id:12, pId:1, name:&quot;父节点12 - 折叠&quot;}, { id:121, pId:12, name:&quot;叶子节点121&quot;}, { id:122, pId:12, name:&quot;叶子节点122&quot;}, { id:123, pId:12, name:&quot;叶子节点123&quot;}, { id:124, pId:12, name:&quot;叶子节点124&quot;}, { id:13, pId:1, name:&quot;父节点13 - 没有子节点&quot;, isParent:true}, { id:2, pId:0, name:&quot;父节点2 - 折叠&quot;}, { id:21, pId:2, name:&quot;父节点21 - 展开&quot;, open:true}, { id:211, pId:21, name:&quot;叶子节点211&quot;}, { id:212, pId:21, name:&quot;叶子节点212&quot;}, { id:213, pId:21, name:&quot;叶子节点213&quot;}, { id:214, pId:21, name:&quot;叶子节点214&quot;}, { id:22, pId:2, name:&quot;父节点22 - 折叠&quot;}, { id:221, pId:22, name:&quot;叶子节点221&quot;}, { id:222, pId:22, name:&quot;叶子节点222&quot;}, { id:223, pId:22, name:&quot;叶子节点223&quot;}, { id:224, pId:22, name:&quot;叶子节点224&quot;}, { id:23, pId:2, name:&quot;父节点23 - 折叠&quot;}, { id:231, pId:23, name:&quot;叶子节点231&quot;}, { id:232, pId:23, name:&quot;叶子节点232&quot;}, { id:233, pId:23, name:&quot;叶子节点233&quot;}, { id:234, pId:23, name:&quot;叶子节点234&quot;}, { id:3, pId:0, name:&quot;父节点3 - 没有子节点&quot;, isParent:true} ]; $.fn.zTree.init($(&quot;#treeDemo&quot;), setting, zNodes); //zTree的初始化方法 }); &lt;/script&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form id=&quot;form1&quot; runat=&quot;server&quot;&gt; &lt;div&gt; &lt;input id=&quot;txtTreeSelect&quot; type=&quot;text&quot; onclick=&quot;showMenu(); return false;&quot;/&gt;//输入框 &lt;/div&gt; &lt;div id=&quot;menuContent&quot; class=&quot;menuContent&quot; style=&quot;display: none; position: absolute;&quot;&gt; &lt;ul id=&quot;treeDemo&quot; class=&quot;ztree&quot; style=&quot;margin-top: 0; width: 120px; height:80px;&quot;&gt; &lt;/ul&gt; &lt;/div&gt;//tree树的div块 &lt;/form&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>zTree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bootstarp框架的bootstrap-table + treegrid组件（列表tree树）]]></title>
    <url>%2F2018%2F12%2F11%2Fbootstarp-table-traagrid%E5%88%97%E8%A1%A8tree%E6%A0%91%2F</url>
    <content type="text"><![CDATA[最近一直在赶项目，很久没更新博客了，今天做完了功能，把这几天学到的东西来用一下 第一个新学到的是bootstarp框架的bootstrap-table + treegrid组件先看图 看代码 需要引入的js &lt;link href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;link href=&quot;https://cdn.bootcss.com/bootstrap-table/1.11.1/bootstrap-table.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.bootcss.com/jquery-treegrid/0.2.0/css/jquery.treegrid.min.css&quot;&gt; &lt;script src=&quot;https://cdn.bootcss.com/jquery/3.1.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/bootstrap-table/1.12.1/bootstrap-table.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/bootstrap-table/1.12.0/extensions/treegrid/bootstrap-table-treegrid.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/jquery-treegrid/0.2.0/js/jquery.treegrid.min.js&quot;&gt;&lt;/script&gt; json数据 var data = JSON.parse( &apos;[{&quot;id&quot;:1,&quot;pid&quot;:0,&quot;status&quot;:1,&quot;name&quot;:&quot;用户管理&quot;,&quot;permissionValue&quot;:&quot;open:user:manage&quot;},&apos; + &apos;{&quot;id&quot;:2,&quot;pid&quot;:0,&quot;status&quot;:1,&quot;name&quot;:&quot;系统管理&quot;,&quot;permissionValue&quot;:&quot;open:system:manage&quot;},&apos; + &apos;{&quot;id&quot;:3,&quot;pid&quot;:1,&quot;status&quot;:1,&quot;name&quot;:&quot;新增用户&quot;,&quot;permissionValue&quot;:&quot;open:user:add&quot;},&apos; + &apos;{&quot;id&quot;:4,&quot;pid&quot;:1,&quot;status&quot;:1,&quot;name&quot;:&quot;修改用户&quot;,&quot;permissionValue&quot;:&quot;open:user:edit&quot;},&apos; + &apos;{&quot;id&quot;:5,&quot;pid&quot;:1,&quot;status&quot;:0,&quot;name&quot;:&quot;删除用户&quot;,&quot;permissionValue&quot;:&quot;open:user:del&quot;},&apos; + &apos;{&quot;id&quot;:6,&quot;pid&quot;:2,&quot;status&quot;:1,&quot;name&quot;:&quot;系统配置管理&quot;,&quot;permissionValue&quot;:&quot;open:systemconfig:manage&quot;},&apos; + &apos;{&quot;id&quot;:7,&quot;pid&quot;:6,&quot;status&quot;:1,&quot;name&quot;:&quot;新增配置&quot;,&quot;permissionValue&quot;:&quot;open:systemconfig:add&quot;},&apos; + &apos;{&quot;id&quot;:8,&quot;pid&quot;:6,&quot;status&quot;:1,&quot;name&quot;:&quot;修改配置&quot;,&quot;permissionValue&quot;:&quot;open:systemconfig:edit&quot;},&apos; + &apos;{&quot;id&quot;:9,&quot;pid&quot;:6,&quot;status&quot;:0,&quot;name&quot;:&quot;删除配置&quot;,&quot;permissionValue&quot;:&quot;open:systemconfig:del&quot;},&apos; + &apos;{&quot;id&quot;:10,&quot;pid&quot;:2,&quot;status&quot;:1,&quot;name&quot;:&quot;系统日志管理&quot;,&quot;permissionValue&quot;:&quot;open:log:manage&quot;},&apos; + &apos;{&quot;id&quot;:11,&quot;pid&quot;:10,&quot;status&quot;:1,&quot;name&quot;:&quot;新增日志&quot;,&quot;permissionValue&quot;:&quot;open:log:add&quot;},&apos; + &apos;{&quot;id&quot;:12,&quot;pid&quot;:10,&quot;status&quot;:1,&quot;name&quot;:&quot;修改日志&quot;,&quot;permissionValue&quot;:&quot;open:log:edit&quot;},&apos; + &apos;{&quot;id&quot;:13,&quot;pid&quot;:10,&quot;status&quot;:0,&quot;name&quot;:&quot;删除日志&quot;,&quot;permissionValue&quot;:&quot;open:log:del&quot;}]&apos;); 设置treegrid $(function() { //控制台输出一下数据 console.log(data); $table.bootstrapTable({ data:data, idField: &apos;id&apos;,//这个id是后台返回的id字段名 dataType:&apos;jsonp&apos;,//这里json或者jsonp格式都行 columns: [ { field: &apos;check&apos;, checkbox: true, formatter: function (value, row, index) { if (row.check == true) { // console.log(row.serverName); //设置选中 return { checked: true }; } } }, { field: &apos;name&apos;, title: &apos;名称&apos; }, // {field: &apos;id&apos;, title: &apos;编号&apos;, sortable: true, align: &apos;center&apos;}, // {field: &apos;pid&apos;, title: &apos;所属上级&apos;}, { field: &apos;status&apos;, title: &apos;状态&apos;, sortable: true, align: &apos;center&apos;, formatter: &apos;statusFormatter&apos; }, //这边说一下在columns中formatter后面跟的方法是页面初始化的时候就会执行的方法 { field: &apos;permissionValue&apos;, title: &apos;权限值&apos; }, { field: &apos;operate&apos;, title: &apos;操作&apos;, align: &apos;center&apos;, events : operateEvents, formatter: &apos;operateFormatter&apos; }, ], // bootstrap-table-treegrid.js 插件配置 -- start //在哪一列展开树形 treeShowField: &apos;name&apos;,//字段名 //指定父id列 parentIdField: &apos;pid&apos;,//父级id onResetView: function(data) { //console.log(&apos;load&apos;); $table.treegrid({ initialState: &apos;collapsed&apos;,// 所有节点都折叠 // initialState: &apos;expanded&apos;,// 所有节点都展开，默认展开 treeColumn: 1, // expanderExpandedClass: &apos;glyphicon glyphicon-minus&apos;, //图标样式 // expanderCollapsedClass: &apos;glyphicon glyphicon-plus&apos;, onChange: function() { $table.bootstrapTable(&apos;resetWidth&apos;); } }); //只展开树形的第一级节点 $table.treegrid(&apos;getRootNodes&apos;).treegrid(&apos;expand&apos;); }, onCheck:function(row){ var datas = $table.bootstrapTable(&apos;getData&apos;); // 勾选子类 selectChilds(datas,row,&quot;id&quot;,&quot;pid&quot;,true); // 勾选父类 selectParentChecked(datas,row,&quot;id&quot;,&quot;pid&quot;) // 刷新数据 $table.bootstrapTable(&apos;load&apos;, datas); }, onUncheck:function(row){ var datas = $table.bootstrapTable(&apos;getData&apos;); selectChilds(datas,row,&quot;id&quot;,&quot;pid&quot;,false); $table.bootstrapTable(&apos;load&apos;, datas); }, // bootstrap-table-treetreegrid.js 插件配置 -- end }); }); 初始化方法 // 格式化按钮 function operateFormatter(value, row, index) { return [ &apos;&lt;button type=&quot;button&quot; class=&quot;RoleOfadd btn-small btn-primary&quot; style=&quot;margin-right:15px;&quot;&gt;&lt;i class=&quot;fa fa-plus&quot; &gt;&lt;/i&gt;&amp;nbsp;新增&lt;/button&gt;&apos;, &apos;&lt;button type=&quot;button&quot; class=&quot;RoleOfedit btn-small btn-primary&quot; style=&quot;margin-right:15px;&quot;&gt;&lt;i class=&quot;fa fa-pencil-square-o&quot; &gt;&lt;/i&gt;&amp;nbsp;修改&lt;/button&gt;&apos;, &apos;&lt;button type=&quot;button&quot; class=&quot;RoleOfdelete btn-small btn-primary&quot; style=&quot;margin-right:15px;&quot;&gt;&lt;i class=&quot;fa fa-trash-o&quot; &gt;&lt;/i&gt;&amp;nbsp;删除&lt;/button&gt;&apos; ].join(&apos;&apos;); } // 格式化类型 function typeFormatter(value, row, index) { if (value === &apos;menu&apos;) { return &apos;菜单&apos;; } if (value === &apos;button&apos;) { return &apos;按钮&apos;; } if (value === &apos;api&apos;) { return &apos;接口&apos;; } return &apos;-&apos;; } // 格式化状态 function statusFormatter(value, row, index) { if (value === 1) { return &apos;&lt;span class=&quot;label label-success&quot;&gt;正常&lt;/span&gt;&apos;; } else { return &apos;&lt;span class=&quot;label label-default&quot;&gt;锁定&lt;/span&gt;&apos;; } } //初始化操作按钮的方法 window.operateEvents = { &apos;click .RoleOfadd&apos;: function (e, value, row, index) { add(row.id); }, &apos;click .RoleOfdelete&apos;: function (e, value, row, index) { del(row.id); }, &apos;click .RoleOfedit&apos;: function (e, value, row, index) { update(row.id); } }; 选中方法 &lt;script&gt; /** * 选中父项时，同时选中子项 * @param datas 所有的数据 * @param row 当前数据 * @param id id 字段名 * @param pid 父id字段名 */ function selectChilds(datas,row,id,pid,checked) { for(var i in datas){ if(datas[i][pid] == row[id]){ datas[i].check=checked; selectChilds(datas,datas[i],id,pid,checked); }; } } function selectParentChecked(datas,row,id,pid){ for(var i in datas){ if(datas[i][id] == row[pid]){ datas[i].check=true; selectParentChecked(datas,datas[i],id,pid); }; } } function test() { var selRows = $table.bootstrapTable(&quot;getSelections&quot;); if(selRows.length == 0){ alert(&quot;请至少选择一行&quot;); return; } var postData = &quot;&quot;; $.each(selRows,function(i) { postData += this.id; if (i &lt; selRows.length - 1) { postData += &quot;， &quot;; } }); alert(&quot;你选中行的 id 为：&quot;+postData); } function add(id) { alert(&quot;add 方法 , id = &quot; + id); } function del(id) { alert(&quot;del 方法 , id = &quot; + id); } function update(id) { alert(&quot;update 方法 , id = &quot; + id); } &lt;/script&gt; 源码已上传百度云：https://pan.baidu.com/s/12GD-LloYGeCswF_nQifVaA 提取二维码]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>bootstrap-table + treegrid - bootstarp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据清洗工具kettle的下载与简单的使用]]></title>
    <url>%2F2018%2F11%2F28%2Fkettle-1%2F</url>
    <content type="text"><![CDATA[1、下载 https://community.hitachivantara.com/docs/DOC-1009855找到这个downloads，可以根据自己下载，我用的是6.0.1.0-3的版本 2、安装的话看自己的磁盘，安装好是这个样子这个Spoon.bat批处理文件就是windows环境启动程序，Spoon.sh是在Linux、AppleOSX、Solaris平台上运行的启动程序 3、启动环境环境就是java的jdk配置环境，jdk 1.5以上就行 ，如何配置jdk就不多说了，可以自己到网上百度4、启动 5、写demo以oracle数据库为例 ceshi数据表结构和表数据 ceshi2数据表结构和表数据 开始写demo，在kettle中双击“转换”或者点“文件–&gt;新建–&gt;转换”或者点击左上角的“+” 打开输入选项，选择表输入，打开输出选项，选择插入/更新（双击或者拖进页面都可以） 把表输入和插入/更新连接起来（选中表输入+shift键，指向插入/更新；或者把鼠标放在表输入上，出现如下图标，选择又箭头） 双击表输入图标，进入表输入 连接之前先把你要链接的数据库的驱动放进kettle的lib目录下 新建链接 测试链接 书写sql，查数据（写完sql可以点击“预览”，看是否是自己想要的数据） 双击插入/更新 新建链接和上一步一样 目标表就是你要把数据导入那个表中 提交记录数量：数据量大的话写1000，数据量小的话默认100就好 用来查询的关键字：点击获取字段获取上一步的字段 更新的字段就是数据更新到那个表的字段 运行 点击倒三角开始运行 点击眼睛图案预览程序运行完成后的样子 图标右上角都有绿色的对号就是程序无误 查看数据 这个是我在网上荡的kettle用户手册链接：https://pan.baidu.com/s/1mGwSqXjZOmLW3Ngk86YHyA 提取码：eplo]]></content>
      <categories>
        <category>数据清洗</category>
      </categories>
      <tags>
        <tag>kettle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[word、excel、ppt转PDF文件]]></title>
    <url>%2F2018%2F11%2F15%2F%E6%96%87%E4%BB%B6%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[今天项目要求做个word、excel转pdf的功能，百般搜刮，测试，终于完成下面这个是word、excel、ppt转pdf功能，支持doc、docx、xls、xlsx、ppt、pptx转pdf1、 准备工作：windows环境、maven项目，普通项目也可以下载jacob.zip，地址：https://sourceforge.net/projects/jacob-project/ 2、 点击 download 就行，下载解压后显示的是 jacob-1.19文件 这个样子 3、 64位系统就用 x64的dll，32位系统就用x86的dll。将dll文件放入放入jdk/bin目录下,如下图所示： 4、 将压缩包中的jacob.jar引入项目 &lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;19.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.jacob&lt;/groupId&gt; &lt;artifactId&gt;jacob&lt;/artifactId&gt; &lt;version&gt;1.18-M2&lt;/version&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt;D:\Maven\maven-repository\jacob\jacob.jar&lt;/systemPath&gt; &lt;/dependency&gt; 5、 展示代码import com.jacob.activeX.ActiveXComponent; import com.jacob.com.ComThread; import com.jacob.com.Dispatch; import com.jacob.com.Variant; public class Demo { private static final Integer WORD_TO_PDF_OPERAND = 17; private static final Integer PPT_TO_PDF_OPERAND = 32; private static final Integer EXCEL_TO_PDF_OPERAND = 0; public void docToPdf(String srcFilePath, String pdfFilePath) throws Exception { ActiveXComponent app = null; Dispatch doc = null; try { ComThread.InitSTA(); app = new ActiveXComponent(&quot;Word.Application&quot;); app.setProperty(&quot;Visible&quot;, false); Dispatch docs = app.getProperty(&quot;Documents&quot;).toDispatch(); Object[] obj = new Object[]{ srcFilePath, new Variant(false), new Variant(false),//是否只读 new Variant(false), new Variant(&quot;pwd&quot;) }; doc = Dispatch.invoke(docs, &quot;Open&quot;, Dispatch.Method, obj, new int[1]).toDispatch(); // Dispatch.put(doc, &quot;Compatibility&quot;, false); //兼容性检查,为特定值false不正确 Dispatch.put(doc, &quot;RemovePersonalInformation&quot;, false); Dispatch.call(doc, &quot;ExportAsFixedFormat&quot;, pdfFilePath, WORD_TO_PDF_OPERAND); // word保存为pdf格式宏，值为17 }catch (Exception e) { e.printStackTrace(); throw e; } finally { if (doc != null) { Dispatch.call(doc, &quot;Close&quot;, false); } if (app != null) { app.invoke(&quot;Quit&quot;, 0); } ComThread.Release(); } } public void pptToPdf(String srcFilePath, String pdfFilePath) throws Exception { ActiveXComponent app = null; Dispatch ppt = null; try { ComThread.InitSTA(); app = new ActiveXComponent(&quot;PowerPoint.Application&quot;); Dispatch ppts = app.getProperty(&quot;Presentations&quot;).toDispatch(); /* * call * param 4: ReadOnly * param 5: Untitled指定文件是否有标题 * param 6: WithWindow指定文件是否可见 * */ ppt = Dispatch.call(ppts, &quot;Open&quot;, srcFilePath, true,true, false).toDispatch(); Dispatch.call(ppt, &quot;SaveAs&quot;, pdfFilePath, PPT_TO_PDF_OPERAND); // ppSaveAsPDF为特定值32 } catch (Exception e) { e.printStackTrace(); throw e; } finally { if (ppt != null) { Dispatch.call(ppt, &quot;Close&quot;); } if (app != null) { app.invoke(&quot;Quit&quot;); } ComThread.Release(); } } public void excelToPdf(String inFilePath, String outFilePath) throws Exception { ActiveXComponent ax = null; Dispatch excel = null; try { ComThread.InitSTA(); ax = new ActiveXComponent(&quot;Excel.Application&quot;); ax.setProperty(&quot;Visible&quot;, new Variant(false)); ax.setProperty(&quot;AutomationSecurity&quot;, new Variant(3)); // 禁用宏 Dispatch excels = ax.getProperty(&quot;Workbooks&quot;).toDispatch(); Object[] obj = new Object[]{ inFilePath, new Variant(false), new Variant(false) }; excel = Dispatch.invoke(excels, &quot;Open&quot;, Dispatch.Method, obj, new int[9]).toDispatch(); // 转换格式 Object[] obj2 = new Object[]{ new Variant(EXCEL_TO_PDF_OPERAND), // PDF格式=0 outFilePath, new Variant(0) //0=标准 (生成的PDF图片不会变模糊) ; 1=最小文件 }; Dispatch.invoke(excel, &quot;ExportAsFixedFormat&quot;, Dispatch.Method,obj2, new int[1]); } catch (Exception es) { es.printStackTrace(); throw es; } finally { if (excel != null) { Dispatch.call(excel, &quot;Close&quot;, new Variant(false)); } if (ax != null) { ax.invoke(&quot;Quit&quot;, new Variant[] {}); ax = null; } ComThread.Release(); } } public static void main(String[] args) throws Exception { String path = &quot;C:\\Users\\lihao\\Desktop\\&quot;; new Demo().docToPdf(path + &quot;实习报告.doc&quot;, path+ &quot;实习报告.pdf&quot;); } } 代码主要参考：https://www.cnblogs.com/xxyfhjl/p/6773786.html]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>文件转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黎活明给程序员得忠告]]></title>
    <url>%2F2018%2F11%2F14%2Fwin10%E4%B8%93%E4%B8%9A%E7%89%88%E6%BF%80%E6%B4%BB%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[展望未来，总结过去10年的程序员生涯，给程序员小弟弟小妹妹们的一些总结性忠告 走过的路，回忆起来是那么曲折，把自己的一些心得体会分享给程序员兄弟姐妹们，虽然时代在变化，但是很可能你也会走我已经做过的10年的路程，有些心得体会你可以借鉴一下，觉得说得有道理的你就接纳，觉得说得没道理的，你就抛弃，以下是我发自内心的，给大家的忠告，特别是针对那些小弟弟妹妹们。 自己的户口档案、养老保险、医疗保险、住房公积金一定要保管好。由于程序员行业每年跳槽一次，我不隐瞒大家，我至少换过5个以上的单位，这期间跳来跳去，甚至是城市都换过3个。还好户口没丢掉，其他都已经是乱了，好几个城市里，都有交过三金，甚至是一个程序的2个区里交的都有，那些东西，10年后，会变得很重要。你买房子若有公积金，可以取出来，贷款利率也会比较低一些，有孩子了，还需要上学，生病了还需要医疗保险。特别是买房子时，你要商业贷款与公积金贷款的利率差别还是很大，有可能会有10万的差距。你平时都注意这些，会给你带来的损失会最小，例如每个月缴纳300元的公积金，公司也缴纳300元，你一个月能存下来600元，一年就是7200元，10年就是72000元。我以前都忽视了这些，到我需要买房子时，公积金里可能只有几千元，10年很快就过去了，结果我没能存下来多少公积金，医疗保险，养老金等更别提了，都已经稀里糊涂了，这些损失10年累加起来，是很庞大的数字，大家要注意，跳槽换工作时也要保护好自身的利益，现在房价很贵，你可能是跟我一样，大山里出来打拼的娃子，家里也没有丰厚的积蓄，只有靠自己拼搏，买房子是人生的一件大事，等你到了10年，才想到这个事情，已经晚了，特别是孩子要上学，上幼儿园等，需要户口啥的都要齐全。 不要轻易换笔记本电脑，不要跟潮流，不要买过多的电子产品，不要过于频繁的更换手机。这方面我的经验教训也是惨痛的。我大概前后购买过5-6个笔记本，以前的都是1万多元一台，最近买的是一台是1万多给女朋友的，自己买了一台是7500元左右，手机大概换过接近10个了，这些钱加起来也足够有10万以上了，你可能一不小心就购买了这些电子产品，但是时间长了，你一回过头来想想，你为什么赚得也不少，但是为什么还是那么穷，是因为你购买这些电子产品花费了过多的金钱了，平时笔记本啥的贵重物品要保护好，我一个同事不小心丢了2台笔记本电脑，接近2万的损失啊，你净赚2万，不是那么容易的，这个窟窿不是开玩笑的，我曾经也被人偷了一个崭新的笔记本，损失1.5万左右，更糟糕的是最新的代码也丢被偷了。 这年代外语、学历、职称、驾驶证还是蛮重要的。想找高薪，外资企业是正确的选择，在同样的打工里，外资企业的收入普遍是高的，我就想不明白，我们的赚钱能力怎么就比不过人家了，社会不断发展，将来可能去外国就像串门一样了，也说不定的，外语好将来的就业机会也会更多更广一些。学历并不代表啥，但是学历也是敲门砖，例如有300个应聘者，那至少重点本科以下的，统统不看了，因为实在是来不及看了，你再厉害也被挡在机会的门外了，同样有时候你想改行什么的，职称也很重要，最起码评个中级职称，说不定还有机会能进入大学或者政府部门还是有可能性。若有充裕的时间，应该把驾驶证考了，因为你越到后面越忙与工作家庭，没机会学车了也说不定的，平时也别光顾拼命工作，工作10年后你才发现，原来身边的人都至少硕士学历了，你被社会自动淘汰了，我现在就有这个感觉，虽然我带过很多硕士，他们的就业机会比我还好，经常能进入名牌企业，我也一直进不去。 不要谈过多的女朋友，谈女朋友要看准，下手要稳准狠。我谈过2个女朋友，平均每个女朋友身上的开支前后大概会有10万左右，还好我不用谈第3个女朋友了，若投资失误，那也是很残忍的，谈女朋友也会消耗很多时间精力、还会消耗很多金钱，实话的讲的确是这样的，人家女孩子也值钱啊，凭什么就那么轻易的跟你啊，我跟第一个朋友分手时，我的生活至少是倒退了3-4年，一切从零开始，一切从头开始，我劝大家谈女朋友是人生最大的一笔买卖，投资失误会有惨痛的后果，不仅仅是金钱上的损失，更会有精神、心灵上的沉重打击，大家要学会珍惜女朋友，要学会哄好女朋友，让老婆开心每一天，虽然鱼儿上钩了，不用再下鱼饵了，偶尔也别忘记放点米，这个鱼要是脱钩了，那不是开玩笑的。 工作不要更换得太过于频繁，选好了行业方向最好别更换太频繁。换工作，换行业方向，就像熊掰苞米一样的道理，有时候是丢了芝麻捡西瓜，有时候是丢了西瓜捡芝麻，这个道理我就不多讲了，大家都应该能明白的。 要对身边的人好，要得到老板的信任、同事的认可及支持、珍惜良好的工作环境。有个朋友的QQ名字很有意思，“只爱陌生人”，陌生人是很有意思，但是最关键时刻，还是需要靠非陌生人，你每天跟同事一起生活，要维系好身边的人。你的成功与失败，往往是你身边的30-40个人决定的。你就是世界首富，他身边也是那么不超过100个人的在左右着他的生活，当你工作10年了，没一个老板信任你，没几个要好的同事朋友，那你惨了，你在这个世界上已经是很孤单了，你的收入，其实大多是来自这些身边的朋友给你介绍的生意，不大会网上掉几个馅饼的。现在你身边的人有可能在不久的将来，给你提供很多好机会。 钱很重要，但是生活质量比钱还重要，工作是很重要，但是家人比工作还重要。钱不是万能的，但是没钱是万万不能的。钱赚了，身体夸了，全送给医院了，钱赚了，身心疲惫了，人活着为了啥？不就为了开开心心生活嘛？工作重要，但是失去了家人的爱，失去了女朋友，失去了老婆孩子，那这个工作有啥用了？工作很容易就换了，家人是换不了的，老婆不是想换就换的，孩子不是想换就换的，连自己的家庭都不负责的人，怎么可能对公司负责呢？我一直是这个观念，来面试时觉得工作更重要的，我们一般不录取的，那太假了，或者太不懂事了。 工作累了，也别太贪玩，有时候还是需要多想想如何才能赚钱。时间一晃就过去了，工作累了是可以适当放松，但是别太贪玩，10年很容易就过去了，10年后你要买房子，要娶老婆，要买车子，要生娃娃，身体也会变得脆弱一些，需要良好的生活习惯，也经不起通宵了，通宵一次，你要低迷好几天才能缓过劲儿来，跟20刚出头完全不一样了，用钱的地方多了去了，父母也会变得更老一些，可能也需要你的照顾，整个家子都指望你赚钱，别到了这个时候，你才意识到赚钱是那么的重要，更何况现在城市的房价，动不动就是100万，加上按揭的利息，你很可能需要支付150万。还可能需要装修，买车子。可能你身上的压力是200万。别觉得谈钱就俗，你要学会赚钱，要有个需要赚钱的良好意识，当然你出身富裕家庭，就不用考虑这些因素了。 每天一点点进步，每月一点点积累，要敬业要爱业，我们给别人提供的也是服务。总有一天，你也会有累的时候，你也会有老的时候，这时候，你要靠啥呢？就要靠你平时的积累，你10年的积累，可以打倒很多竞争对手，他们再厉害，再怎么样，也很难抵得过你10年的积累，特别是后面5-10年的积累，成果会很明显，前面的1-5年，算是做软件的入门吧，除非你有高人指点，那可能2-3年就可以修成正果，软件在将来还是会值钱的，以为生活会越来越智能化，越来越数字化，软件的需求还是很有前途，最起码未来的10-20年里不用太担心失业问题了。 对程序员来讲，开发思想、架构、代码就是财富，别老丢弃你的劳动成果，要学会保护你的劳动成果。 我大概7-8年前的代码都在手上，经常改进来改进去，维护来维护去，在一定的程度上，让我生活轻松了不少，因为我不用什么都从头来过，我只要痛苦一次，以后就要反复重复利用，软件的价值在于重复利用，而不是每个东西，都从头开发，那永远也是辛苦的程序员，这个生活质量就别提了，不管自己的代码丑还是拿不出手，要学会精心维护，每天改进一点点，每个月一个小进步，每年一个大进步，多年的积累是宝贵的，这个早晚也会给你带来丰厚的收益。 当程序员要防止原地踏步，不是工作年限长了，经验就丰富了，能力就强了，年纪越大工作越难找。 我有一个朋友跟我开玩笑，工作5年的人，可能能力差距会很大，为什么呢？因为第一年他们干的事情都是一样的，都写程序了，2个人可能由于价值观不一样，5年后差距会很大，甚至是大到无法追赶的程度，为啥？因为还有机会的因素在里面，有的人干了5年，还是在原地踏步，天天只会写那些添加、删除、修改的代码。那你得注意了，需要不断的提高自己，才是硬道理。例如你会SQLServer，那要试着学习Oracle，你是做C/S的，那得需要提高到B/S的，你是做单机软件的，那得需要提高到网络软件，你只关注自己的工作的，需要学会管理，关心他人的工作。你是当程序员的，要试着提高当项目经理、部门经理，公司的总监等等，人有野心有目标才会不断进步，最俗的为了多赚钱，提高工作职位工作岗位，工作单位，也是可以理解的。年纪越大工作越难找，例如3-4千的工作是随便找找，玩一样，但是你30过后，最起码要找月薪上1万的工作，这样的工作是机会也少，一般小公司也给不起，还得找个好公司才可以，好公司又不是天天招聘人，天天缺好的工作岗位，说不好听点儿，小公司的老板才赚多少啊？他来钱也很不容易的，小池塘就不好容得下大鲨鱼了。 当创业的收入比打工还少时，那就别创业，要找比自己能力强的人创业，你不会吃亏。创业的收入，比打工还少，那就是瞎扯蛋，恶搞。创业的真正意思并不是要你去吃苦没钱赚，那是忽悠无知的人的。当你创业时的收入，比打工还多，那你可以考虑创业，没有工资什么的，股份啥的，都是瞎扯蛋。不要跟自己能力还弱的人一起创业，那损失最大的，很可能就是你，要创业，也要找比自己强的人一起创业，最起码赚不到钱，还能学到不少。不会有过多的损失。别热血一沸腾就创业了，创业了，也别烧自己的钱，家人的钱，那是很不抗烧的，没几下几十万就烧干了。其实打工，也是创业的开始，每个月都能拿到钱，还可以学到知识，什么公司的股份都是空话，没几个小公司能成功，开起来了也走不了3年就分家了，都忽悠小孩子玩的，除非真的有科技含量或者是客户资源的，否则股份是一文钱不值的，就算创业每个月也按时拿工资才是硬道理。 未来的生活节奏会更快，生活压力会更大，竞争会更激烈，社会服务体系会更完善。在未来，我们享受良好的服务的同时，也会为别人提供更良好的服务，需要在技能上还是服务质量上的要求会更高更严格。平时要注意提高自己，不要被时代淘汰掉，我从小的朋友，一波又一波被社会无情的淘汰了，很小的时候，我出生在大草原与大山的交界处，我小时候的玩伴，还在大山里，我跟着家人杀出来了，我小学、中学、大学、工作上的、这10年，我一直很坚强的拼搏下来，很不容易的在杭州立住脚了，说实话，参加工作后的十年，也是不断拼搏，不断提高的十年。]]></content>
      <categories>
        <category>软文</category>
      </categories>
      <tags>
        <tag>文章</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis-plus 条件包装类使用工具 EntityWrapper]]></title>
    <url>%2F2018%2F11%2F08%2FMybatis-EntryWrapper%2F</url>
    <content type="text"><![CDATA[使用T selectOne(Wrapper wrapper);我们只需要传递入我们创建一个EntityWrapper()并将条件拼接好就可以。例如new EntityWrapper().eq(“id”,”1”)就是查询id等于1的这条数据。这里不仅仅支持eq(),还有like,not like ,group by等，差不多在SQL中需要的这里都有,可以自己慢慢发掘 上代码 List&lt;ApplyEntity&gt; list = devApplyService.selectList(new EntityWrapper&lt;ApplyEntity&gt;() .eq(&quot;code&quot;,code).eq(&quot;status&quot;,status).eq(&quot;orgid&quot;,orgid).isNotNull(&quot;auditresult&quot;)); Entity entity=sysDdService.selectOne(new EntityWrapper&lt;SysDdtEntity&gt;().eq(&quot;dict_type&quot;, &quot;CAR_AREA&quot;));]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Mybatis-EntityWrapper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[遍历Map的四种方法]]></title>
    <url>%2F2018%2F11%2F08%2Ffor-map%2F</url>
    <content type="text"><![CDATA[import java.util.HashMap; import java.util.Iterator; import java.util.Map; public class TestMap { public static void main(String[] args) { Map&lt;Integer, String&gt; map = new HashMap&lt;Integer, String&gt;(); map.put(1, &quot;a&quot;); map.put(2, &quot;b&quot;); map.put(3, &quot;ab&quot;); map.put(4, &quot;ab&quot;);// 和上面相同 ， 会自己筛选 System.out.println(map.size()); // 第一种： System.out.println(&quot;第一种：通过Map.keySet遍历key和value：&quot;); for (Integer in : map.keySet()) { //map.keySet()返回的是所有key的值 String str = map.get(in);//得到每个key多对用value的值 System.out.println(in + &quot; &quot; + str); } // 第二种： System.out.println(&quot;第二种：通过Map.entrySet使用iterator遍历key和value：&quot;); Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; it = map.entrySet().iterator(); while (it.hasNext()) { Map.Entry&lt;Integer, String&gt; entry = it.next(); System.out.println(&quot;key= &quot; + entry.getKey() + &quot; and value= &quot; + entry.getValue()); } // 第三种：推荐，尤其是容量大时 System.out.println(&quot;第三种：通过Map.entrySet遍历key和value&quot;); for (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) { //Map.entry&lt;Integer,String&gt; 映射项（键-值对） 有几个方法：用上面的名字entry //entry.getKey() ;entry.getValue(); entry.setValue(); //map.entrySet() 返回此映射中包含的映射关系的 Set视图。 System.out.println(&quot;key= &quot; + entry.getKey() + &quot; and value= &quot; + entry.getValue()); } // 第四种： System.out.println(&quot;第四种：通过Map.values()遍历所有的value，但不能遍历key&quot;); for (String v : map.values()) { System.out.println(&quot;value= &quot; + v); } } }]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Map遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[base64和图片的互相转换]]></title>
    <url>%2F2018%2F11%2F07%2Fbase64%2F</url>
    <content type="text"><![CDATA[今天刚把博客收拾好，迫不及待来发布一篇文章，有错误之处还请大神们指出来，上代码import java.io.ByteArrayOutputStream; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.net.HttpURLConnection; import java.net.URL; import com.steward.utils.StringUtil; import sun.misc.BASE64Decoder; import sun.misc.BASE64Encoder; @SuppressWarnings(&quot;restriction&quot;) public class Base64Utils { public static void main(String[] args) throws Exception { //本地图片地址 String url = &quot;C:/Users/Administrator/Desktop/628947887489084892.jpg&quot;; //在线图片地址 String string = &quot;http://bpic.588ku.com//element_origin_min_pic/17/03/03/7bf4480888f35addcf2ce942701c728a.jpg&quot;; String str = Base64Utils.ImageToBase64ByLocal(url); String ste = Base64Utils.ImageToBase64ByOnline(string); System.out.println(str); Base64Utils.Base64ToImage(str,&quot;C:/Users/Administrator/Desktop/test1.jpg&quot;); Base64Utils.Base64ToImage(ste, &quot;C:/Users/Administrator/Desktop/test2.jpg&quot;); } /** * 本地图片转换成base64字符串 * @param imgFile 图片本地路径 * @return * * @author ZHANGJL * @dateTime 2018-02-23 14:40:46 */ public static String ImageToBase64ByLocal(String imgFile) {// 将图片文件转化为字节数组字符串，并对其进行Base64编码处理 InputStream in = null; byte[] data = null; // 读取图片字节数组 try { in = new FileInputStream(imgFile); data = new byte[in.available()]; in.read(data); in.close(); } catch (IOException e) { e.printStackTrace(); } // 对字节数组Base64编码 BASE64Encoder encoder = new BASE64Encoder(); return encoder.encode(data);// 返回Base64编码过的字节数组字符串 } /** * 在线图片转换成base64字符串 * * @param imgURL 图片线上路径 * @return * * @author ZHANGJL * @dateTime 2018-02-23 14:43:18 */ public static String ImageToBase64ByOnline(String imgURL) { ByteArrayOutputStream data = new ByteArrayOutputStream(); try { // 创建URL URL url = new URL(imgURL); byte[] by = new byte[1024]; // 创建链接 HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.setRequestMethod(&quot;GET&quot;); conn.setConnectTimeout(5000); InputStream is = conn.getInputStream(); // 将内容读取内存中 int len = -1; while ((len = is.read(by)) != -1) { data.write(by, 0, len); } // 关闭流 is.close(); } catch (IOException e) { e.printStackTrace(); } // 对字节数组Base64编码 BASE64Encoder encoder = new BASE64Encoder(); return encoder.encode(data.toByteArray()); } /** * base64字符串转换成图片 * @param imgStr base64字符串 * @param imgFilePath 图片存放路径 * @return * * @author ZHANGJL * @dateTime 2018-02-23 14:42:17 */ public static boolean Base64ToImage(String imgStr,String imgFilePath) { // 对字节数组字符串进行Base64解码并生成图片 if (StringUtil.isEmpty(imgStr)) // 图像数据为空 return false; BASE64Decoder decoder = new BASE64Decoder(); try { // Base64解码 byte[] b = decoder.decodeBuffer(imgStr); for (int i = 0; i &lt; b.length; ++i) { if (b[i] &lt; 0) {// 调整异常数据 b[i] += 256; } } OutputStream out = new FileOutputStream(imgFilePath); out.write(b); out.flush(); out.close(); return true; } catch (Exception e) { return false; } } }]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>图片和流@1</tag>
      </tags>
  </entry>
</search>
