<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[IO流（一）]]></title>
    <url>%2F2018%2F12%2F19%2FIO-1%2F</url>
    <content type="text"><![CDATA[IO流的分类 按照操作的对象不同可分为字节流与字符流 按照流的方向不同可分为输入（指从外部存储设备拿文件到内存）流也叫读与输出（指从内存把文件写入到外部存储设备）流也叫写 注：字节流可以操作任何类型的文件，字符流是后来才出现的，主要用来操作字符类的文件；字符流的出现源于编码表的问题，一开始计算机内使用ANSII编码，后来每种语言都有了自己的编码方式即编码表，为了统一这些编码信息国际标准化组织便产生了Unicode编码信息表来把世界各国的语言都包括在内，此编码表采用两个字节即16位来存储每一个字符，java内置的编码表便是Unicode编码；字符流是当读取文件的时候，以字节的形式读取后，查询编码表看具体使用哪种编码方式，查到以后再进行文件的输出，所以字符流是字节流+查编码表的封装形式。 流的顶层基类所有流的操作无非两种形式：读与写；所以Java便所这两种操作形式抽取出了字节流与字符流的两种顶层的基类 字节流的顶层基类：InputStream与OutputStream 字符流的顶层基类：Read与Write 代码部分import java.io.BufferedReader; import java.io.BufferedWriter; import java.io.FileReader; import java.io.FileWriter; import java.io.IOException; import java.io.LineNumberReader; public class FileTest { public static void main(String[] args) { try { function_demo7(); } catch (IOException e) { // TODO 自动生成的 catch 块 e.printStackTrace(); } } /** * 字符流FileWite */ public static void function_demo1() throws IOException { // 创建字符写入流对象，接收一个要写入的文件路径对象，此文件若不存在则新创建一个文件，若已存在则覆盖的文件 FileWriter fw = new FileWriter(&quot;C:\\Users\\lihao\\Desktop\\file\\demo1.txt&quot;); fw.write(&quot;abcdefg&quot;);// 把内容写入缓冲区 fw.flush();// 从缓冲区把内容刷入文件中 fw.close();// 关闭流 //注：以上代码中fw.flush()是把内容从缓冲区刷入到文件中去， //但是fw.close()方法是先把内容从缓冲区刷入到文件中去即先调用flush方法，所以fw.flush()可以不用 } /** * FileWite换行和续写 */ // 获取系统换行的符号 private static final String LINE_SEPARATOR = System.getProperty(&quot;line.separator&quot;); public static void function_demo2() throws IOException { FileWriter writer = new FileWriter(&quot;C:\\Users\\lihao\\Desktop\\file\\demo2.txt&quot;, true);// 创建写入流对象 // 把内容写入到缓冲区 writer.write(&quot;abcdef绵&quot; + LINE_SEPARATOR + &quot;中国人啊啊啊啊啊啊啊&quot;); // 把缓冲区里的内容刷入到文件系统中 // writer.flush(); // 关闭流，在关闭之前会先把缓冲区里的内容刷入到文件系统然后才关闭流；若用此关闭流可不用手动调用flush writer.close(); //注：FileWriter在支持续写的时候提供了一个带两个参数的构造函数，当传递为true时即可支持续写；换行可调用系统提供的换行符号 } /** * 字符流FileReader */ public static void function_demo3() throws IOException { // 创建读取流对象，指定需要读取的文件地址 FileReader reader = new FileReader(&quot;C:\\Users\\lihao\\Desktop\\file\\demo2.txt&quot;); // 声明一个变量接收读取到的字符 int ch; // 调用read方法读取文件中的字符，当读取到文件的末尾的时候read方法返回-1 while ((ch = reader.read()) != -1) { System.out.println((char) ch); } // 关闭流 reader.close(); //注：此读取方式为一个字符的读取，每读取一个字符便写到控制台， //以下代码演示高效的读取，即声明一个缓冲区的数组，把每次所读到的内容先放入缓冲数组中去，然后再一次性写到文件中 } public static void function_demo4() throws IOException { //读取流对象 FileReader reader = new FileReader(&quot;C:\\Users\\lihao\\Desktop\\file\\demo2.txt&quot;); //每次读取到的字符放入的缓冲数组区 char[] buf = new char[1024]; //每次读取到的字符数 int i; //循环读取，每次read一次把读取到的内容放入buf字符数组，读到最后会返回-1 while ((i = reader.read(buf)) != -1) { //把读取到的字符转为字符串，每次转换的数量为读取到的字符数 System.out.println(new String(buf, 0, i)); } reader.close(); } /** * 下面用两种方式实现文件的复制功能 */ private static void function_demo5() throws IOException { FileReader fr = new FileReader(&quot;C:\\Users\\lihao\\Desktop\\file\\demo1.txt&quot;);//创建读取流对象 FileWriter fw = new FileWriter(&quot;C:\\Users\\lihao\\Desktop\\file\\demo2.txt&quot;);//创建写入流对象，若文件不存在则创建；若存在则覆盖 int ch;//存储读取到的字符 //循环读取文件中的数据 while ((ch = fr.read()) != -1) { fw.write(ch);//把每次读到的内容写入到新文件中 } fw.close();//关闭 fr.close();//关闭 } /** * 高效的文件复制 */ private static void function_demo6() throws IOException { FileReader fr = new FileReader(&quot;C:\\Users\\lihao\\Desktop\\file\\demo1.txt&quot;);// 创建读取流对象 FileWriter fw = new FileWriter(&quot;C:\\Users\\lihao\\Desktop\\file\\demo2.txt&quot;);// 创建写入流对象，若文件不存在则创建，若存在则覆盖 char[] buf = new char[4096];//缓存数组 int ch;// 存储读取到的字符 // 循环读取文件中的数据 while ((ch = fr.read(buf)) != -1) {//把每次读取到的内容放入缓存数组中 fw.write(buf, 0, ch);//从缓存数组中把内容读出来 } fw.close();//关闭流 fr.close();//关闭流 } /** * 高效的读取流BufferReader * 从字符输入流中读取文本，缓冲各个字符，从而实现字符、数组和行的高效读取。 * 注意，此类可以直接读取行，由此也说明此类是专门为高效的读取文件数据的方式 */ private static void function_demo7() throws IOException { FileReader fr = new FileReader(&quot;C:\\Users\\lihao\\Desktop\\file\\demo2.txt&quot;);//读取流对象 BufferedReader bReader = new BufferedReader(fr);//缓冲读取流对象，需要传入读取Reader的实现类 int ch; while ((ch = bReader.read()) != -1) {//此read为增强了的read方法，用的装饰器模式 System.out.println((char) ch); } bReader.close();//关闭该流并释放与之关联的所有资源；即也把读取流的对象fr给关闭了，不需要再手动调用fr.close() } /** * 带缓冲数组的读取 */ private static void function_demo8() throws IOException { FileReader fr = new FileReader(&quot;demo.txt&quot;);// 读取流对象 BufferedReader bReader = new BufferedReader(fr);// 缓冲读取流对象，需要传入读取Reader的实现类 int ch = 0; char[] buff = new char[1024]; while ((ch = bReader.read(buff)) != -1) {// 此read为增强了的read方法，用的装饰器模式 System.out.println(new String(buff, 0, ch)); } bReader.close();// 关闭该流并释放与之关联的所有资源；即也把读取流的对象fr给关闭了，不需要再手动调用fr.close() } /** * 读取行 * @throws IOException */ private static void function_demo9() throws IOException { FileReader fr = new FileReader(&quot;demo.txt&quot;); BufferedReader bReader = new BufferedReader(fr); String line = null;//获取每次读到的行内容 while ((line = bReader.readLine()) != null) {//如果读取到了最后，则返回null System.out.println(line); } bReader.close(); } /** * 高效的写入流BufferedWriter * 将文本写入字符输出流，缓冲各个字符，从而提供单个字符、数组和字符串的高效写入。此流写入的时候提供了一个newLine方法，可换行。 */ private static void function_demo10() throws IOException { FileWriter fw = new FileWriter(&quot;demo4.txt&quot;); BufferedWriter bw = new BufferedWriter(fw); bw.write(&quot;LioneTree&quot;); bw.newLine(); bw.write(&quot;go kb go kb nnw huo kb &quot;); bw.close(); } /** * 使用BufferedReader与BufferedWriter实现文件复制的功能 */ private static void function_demo11() throws IOException { FileReader fReader = new FileReader(&quot;demo.txt&quot;);//读取流对象 BufferedReader bReader = new BufferedReader(fReader);//缓冲读取流对象，传入fReader读取流对象 FileWriter fWriter = new FileWriter(&quot;demo5.txt&quot;);//写入流对象 BufferedWriter bWriter = new BufferedWriter(fWriter);//缓冲写入流对象，传入bWriter写入流对象 String line=null;//存储每次读取到的行内容 while((line=bReader.readLine())!=null) {//如果文件内容读完了则返回null bWriter.write(line);//写入读取到的每行内容 bWriter.newLine();//每读完一行则换行 } bReader.close();//关闭读取流对象 bWriter.close();//关闭写入流对象 } /** * 跟踪行号的缓冲字符输入流LineNumberReader * 此类定义了方法 setLineNumber(int) 和 getLineNumber()，它们可分别用于设置和获取当前行号；字继承自BufferedReader类 */ private static void function_demo12() throws IOException { FileReader fr = new FileReader(&quot;demo.txt&quot;);// 读取流对象 LineNumberReader lnr = new LineNumberReader(fr);// 行号读取流对象，需要传入读取流fr对象 String line = null;// 存储读取到的内容 lnr.setLineNumber(100);// 设置起始行号，若不设置默认从0开始，在读取到的每一行的末尾处自增1 while ((line = lnr.readLine()) != null) {// 按行读取 System.out.println(lnr.getLineNumber() + &quot; &quot; + line); } lnr.close(); } }]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>IO流</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[input下拉tree树（zTree插件）]]></title>
    <url>%2F2018%2F12%2F11%2Finput-zTree%2F</url>
    <content type="text"><![CDATA[这次做项目还用到了另一个tree树的插件，就是input输入框下拉tree树 我这只是简单的下拉显示tree树，没有tree树的添加、编辑、删除、移动等操作先看图片 zTree官方API文档http://www.treejs.cn/v3/api.php 上代码 引入的js &lt;script src=&quot;js/jquery-1.4.4.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;link href=&quot;css/zTreeStyle/zTreeStyle.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; &lt;script src=&quot;js/jquery.ztree.core-3.5.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/jquery.ztree.excheck-3.5.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; js文件包括源码上传至百度云：https://pan.baidu.com/s/1iOtplePD1gwYBme8y4BD4w 代码 &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; &gt; &lt;head runat=&quot;server&quot;&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;!-- for HTML5 --&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;script src=&quot;js/jquery-1.4.4.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;link href=&quot;css/zTreeStyle/zTreeStyle.css&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt; &lt;script src=&quot;js/jquery.ztree.core-3.5.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;script src=&quot;js/jquery.ztree.excheck-3.5.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var setting = { view: { showIcon: false//设置 zTree 是否显示节点的图标。默认值：true showLine: false//设置 zTree 是否显示节点之间的连线。默认值：true }, data: { simpleData: { enable: true//确定 zTree 初始化时的节点数据、异步加载时的节点数据、或 addNodes 方法中输入的 newNodes 数据是否采用简单数据模式 (Array) 不需要用户再把数据库中取出的 List 强行转换为复杂的 JSON 嵌套格式 默认值：false ztree有两种数据格式1、标准数据格式 2、简单数据格式（我们常用的json数据格式，也就是我下面的数据格式） idKey: &quot;id&quot;,//你后台返回的json的id字段（节点数据中保存唯一标识的属性名称。[setting.data.simpleData.enable = true 时生效]） pIdKey: &quot;pId&quot;,//你后台返回的json的父级id字段（节点数据中保存其父节点唯一标识的属性名称。[setting.data.simpleData.enable = true 时生效]） rootPId: 0（用于修正根节点父节点数据，即 pIdKey 指定的属性值。[setting.data.simpleData.enable = true 时生效]） } }, callback: { onClick: onClick//用于捕获节点被点击的事件回调函数 //如果设置了 setting.callback.beforeClick 方法，且返回 false，将无法触发 onClick 事件回调函数。 } }; var filename; var parentids; var parentId; function onClick(e, treeId, treeNode) { $(&apos;#txtTreeSelect&apos;).val(treeNode.name); alert(treeNode.tId + &quot;, &quot; + treeNode.name);//每次点击节点后， 弹出该节点的 Id、name 的信息 filename = getFilePath(treeNode);//获取所有父节点的名字 parentids = getFileId(treeNode);//获取所有父节点的id parentId = treeNode.id;//获取点击节点的id } //获取所有父节点名字 function getFilePath(treeObj){ if(treeObj==null)return &quot;&quot;; var filename = treeObj.name; var pNode = treeObj.getParentNode(); if(pNode!=null){ filename = getFilePath(pNode) +&quot;&gt;&quot;+ filename; } return filename; } //获取所有父节点id function getFileId(treeObj){ if(treeObj==null)return &quot;&quot;; var id = treeObj.id; var pNode = treeObj.getParentNode(); if(pNode!=null){ id = getFileId(pNode) +&quot;&gt;&quot;+ id; } return id; } function showMenu() {//输入框的点击事件 var cityObj = $(&apos;#txtTreeSelect&apos;); var cityOffset = cityObj.offset(); $(&quot;#menuContent&quot;).css({ left: cityOffset.left + &quot;px&quot;, top: cityOffset.top + cityObj.outerHeight() + &quot;px&quot; }).slideDown(&quot;fast&quot;); $(&quot;body&quot;).bind(&quot;mousedown&quot;, onBodyDown); } function hideMenu() {//初始化隐藏下拉树 $(&quot;#menuContent&quot;).fadeOut(&quot;fast&quot;); $(&quot;body&quot;).unbind(&quot;mousedown&quot;, onBodyDown); } function onBodyDown(event) {//树的主体 if (!(event.target.id == &quot;menuBtn&quot; || event.target.id == &quot;menuContent&quot; || $(event.target).parents(&quot;#menuContent&quot;).length &gt; 0)) { hideMenu(); } } $(document).ready(function () {//一进页面就会加载的方法 var zNodes =[//自定义json { id:1, pId:0, name:&quot;父节点1 - 展开&quot;, open:true,url:&quot;jyy&quot;}, { id:11, pId:1, name:&quot;父节点11 - 折叠&quot;}, { id:111, pId:11, name:&quot;叶子节点111&quot;}, { id:112, pId:11, name:&quot;叶子节点112&quot;}, { id:113, pId:11, name:&quot;叶子节点113&quot;}, { id:114, pId:11, name:&quot;叶子节点114&quot;}, { id:12, pId:1, name:&quot;父节点12 - 折叠&quot;}, { id:121, pId:12, name:&quot;叶子节点121&quot;}, { id:122, pId:12, name:&quot;叶子节点122&quot;}, { id:123, pId:12, name:&quot;叶子节点123&quot;}, { id:124, pId:12, name:&quot;叶子节点124&quot;}, { id:13, pId:1, name:&quot;父节点13 - 没有子节点&quot;, isParent:true}, { id:2, pId:0, name:&quot;父节点2 - 折叠&quot;}, { id:21, pId:2, name:&quot;父节点21 - 展开&quot;, open:true}, { id:211, pId:21, name:&quot;叶子节点211&quot;}, { id:212, pId:21, name:&quot;叶子节点212&quot;}, { id:213, pId:21, name:&quot;叶子节点213&quot;}, { id:214, pId:21, name:&quot;叶子节点214&quot;}, { id:22, pId:2, name:&quot;父节点22 - 折叠&quot;}, { id:221, pId:22, name:&quot;叶子节点221&quot;}, { id:222, pId:22, name:&quot;叶子节点222&quot;}, { id:223, pId:22, name:&quot;叶子节点223&quot;}, { id:224, pId:22, name:&quot;叶子节点224&quot;}, { id:23, pId:2, name:&quot;父节点23 - 折叠&quot;}, { id:231, pId:23, name:&quot;叶子节点231&quot;}, { id:232, pId:23, name:&quot;叶子节点232&quot;}, { id:233, pId:23, name:&quot;叶子节点233&quot;}, { id:234, pId:23, name:&quot;叶子节点234&quot;}, { id:3, pId:0, name:&quot;父节点3 - 没有子节点&quot;, isParent:true} ]; $.fn.zTree.init($(&quot;#treeDemo&quot;), setting, zNodes); //zTree的初始化方法 }); &lt;/script&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form id=&quot;form1&quot; runat=&quot;server&quot;&gt; &lt;div&gt; &lt;input id=&quot;txtTreeSelect&quot; type=&quot;text&quot; onclick=&quot;showMenu(); return false;&quot;/&gt;//输入框 &lt;/div&gt; &lt;div id=&quot;menuContent&quot; class=&quot;menuContent&quot; style=&quot;display: none; position: absolute;&quot;&gt; &lt;ul id=&quot;treeDemo&quot; class=&quot;ztree&quot; style=&quot;margin-top: 0; width: 120px; height:80px;&quot;&gt; &lt;/ul&gt; &lt;/div&gt;//tree树的div块 &lt;/form&gt; &lt;/body&gt; &lt;/html&gt;]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>zTree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bootstarp框架的bootstrap-table + treegrid组件（列表tree树）]]></title>
    <url>%2F2018%2F12%2F11%2Fbootstarp-table-traagrid%E5%88%97%E8%A1%A8tree%E6%A0%91%2F</url>
    <content type="text"><![CDATA[最近一直在赶项目，很久没更新博客了，今天做完了功能，把这几天学到的东西来用一下 第一个新学到的是bootstarp框架的bootstrap-table + treegrid组件先看图 看代码 需要引入的js &lt;link href=&quot;https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;link href=&quot;https://cdn.bootcss.com/bootstrap-table/1.11.1/bootstrap-table.min.css&quot; rel=&quot;stylesheet&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.bootcss.com/jquery-treegrid/0.2.0/css/jquery.treegrid.min.css&quot;&gt; &lt;script src=&quot;https://cdn.bootcss.com/jquery/3.1.1/jquery.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/bootstrap-table/1.12.1/bootstrap-table.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/bootstrap-table/1.12.0/extensions/treegrid/bootstrap-table-treegrid.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;https://cdn.bootcss.com/jquery-treegrid/0.2.0/js/jquery.treegrid.min.js&quot;&gt;&lt;/script&gt; json数据 var data = JSON.parse( &apos;[{&quot;id&quot;:1,&quot;pid&quot;:0,&quot;status&quot;:1,&quot;name&quot;:&quot;用户管理&quot;,&quot;permissionValue&quot;:&quot;open:user:manage&quot;},&apos; + &apos;{&quot;id&quot;:2,&quot;pid&quot;:0,&quot;status&quot;:1,&quot;name&quot;:&quot;系统管理&quot;,&quot;permissionValue&quot;:&quot;open:system:manage&quot;},&apos; + &apos;{&quot;id&quot;:3,&quot;pid&quot;:1,&quot;status&quot;:1,&quot;name&quot;:&quot;新增用户&quot;,&quot;permissionValue&quot;:&quot;open:user:add&quot;},&apos; + &apos;{&quot;id&quot;:4,&quot;pid&quot;:1,&quot;status&quot;:1,&quot;name&quot;:&quot;修改用户&quot;,&quot;permissionValue&quot;:&quot;open:user:edit&quot;},&apos; + &apos;{&quot;id&quot;:5,&quot;pid&quot;:1,&quot;status&quot;:0,&quot;name&quot;:&quot;删除用户&quot;,&quot;permissionValue&quot;:&quot;open:user:del&quot;},&apos; + &apos;{&quot;id&quot;:6,&quot;pid&quot;:2,&quot;status&quot;:1,&quot;name&quot;:&quot;系统配置管理&quot;,&quot;permissionValue&quot;:&quot;open:systemconfig:manage&quot;},&apos; + &apos;{&quot;id&quot;:7,&quot;pid&quot;:6,&quot;status&quot;:1,&quot;name&quot;:&quot;新增配置&quot;,&quot;permissionValue&quot;:&quot;open:systemconfig:add&quot;},&apos; + &apos;{&quot;id&quot;:8,&quot;pid&quot;:6,&quot;status&quot;:1,&quot;name&quot;:&quot;修改配置&quot;,&quot;permissionValue&quot;:&quot;open:systemconfig:edit&quot;},&apos; + &apos;{&quot;id&quot;:9,&quot;pid&quot;:6,&quot;status&quot;:0,&quot;name&quot;:&quot;删除配置&quot;,&quot;permissionValue&quot;:&quot;open:systemconfig:del&quot;},&apos; + &apos;{&quot;id&quot;:10,&quot;pid&quot;:2,&quot;status&quot;:1,&quot;name&quot;:&quot;系统日志管理&quot;,&quot;permissionValue&quot;:&quot;open:log:manage&quot;},&apos; + &apos;{&quot;id&quot;:11,&quot;pid&quot;:10,&quot;status&quot;:1,&quot;name&quot;:&quot;新增日志&quot;,&quot;permissionValue&quot;:&quot;open:log:add&quot;},&apos; + &apos;{&quot;id&quot;:12,&quot;pid&quot;:10,&quot;status&quot;:1,&quot;name&quot;:&quot;修改日志&quot;,&quot;permissionValue&quot;:&quot;open:log:edit&quot;},&apos; + &apos;{&quot;id&quot;:13,&quot;pid&quot;:10,&quot;status&quot;:0,&quot;name&quot;:&quot;删除日志&quot;,&quot;permissionValue&quot;:&quot;open:log:del&quot;}]&apos;); 设置treegrid $(function() { //控制台输出一下数据 console.log(data); $table.bootstrapTable({ data:data, idField: &apos;id&apos;,//这个id是后台返回的id字段名 dataType:&apos;jsonp&apos;,//这里json或者jsonp格式都行 columns: [ { field: &apos;check&apos;, checkbox: true, formatter: function (value, row, index) { if (row.check == true) { // console.log(row.serverName); //设置选中 return { checked: true }; } } }, { field: &apos;name&apos;, title: &apos;名称&apos; }, // {field: &apos;id&apos;, title: &apos;编号&apos;, sortable: true, align: &apos;center&apos;}, // {field: &apos;pid&apos;, title: &apos;所属上级&apos;}, { field: &apos;status&apos;, title: &apos;状态&apos;, sortable: true, align: &apos;center&apos;, formatter: &apos;statusFormatter&apos; }, //这边说一下在columns中formatter后面跟的方法是页面初始化的时候就会执行的方法 { field: &apos;permissionValue&apos;, title: &apos;权限值&apos; }, { field: &apos;operate&apos;, title: &apos;操作&apos;, align: &apos;center&apos;, events : operateEvents, formatter: &apos;operateFormatter&apos; }, ], // bootstrap-table-treegrid.js 插件配置 -- start //在哪一列展开树形 treeShowField: &apos;name&apos;,//字段名 //指定父id列 parentIdField: &apos;pid&apos;,//父级id onResetView: function(data) { //console.log(&apos;load&apos;); $table.treegrid({ initialState: &apos;collapsed&apos;,// 所有节点都折叠 // initialState: &apos;expanded&apos;,// 所有节点都展开，默认展开 treeColumn: 1, // expanderExpandedClass: &apos;glyphicon glyphicon-minus&apos;, //图标样式 // expanderCollapsedClass: &apos;glyphicon glyphicon-plus&apos;, onChange: function() { $table.bootstrapTable(&apos;resetWidth&apos;); } }); //只展开树形的第一级节点 $table.treegrid(&apos;getRootNodes&apos;).treegrid(&apos;expand&apos;); }, onCheck:function(row){ var datas = $table.bootstrapTable(&apos;getData&apos;); // 勾选子类 selectChilds(datas,row,&quot;id&quot;,&quot;pid&quot;,true); // 勾选父类 selectParentChecked(datas,row,&quot;id&quot;,&quot;pid&quot;) // 刷新数据 $table.bootstrapTable(&apos;load&apos;, datas); }, onUncheck:function(row){ var datas = $table.bootstrapTable(&apos;getData&apos;); selectChilds(datas,row,&quot;id&quot;,&quot;pid&quot;,false); $table.bootstrapTable(&apos;load&apos;, datas); }, // bootstrap-table-treetreegrid.js 插件配置 -- end }); }); 初始化方法 // 格式化按钮 function operateFormatter(value, row, index) { return [ &apos;&lt;button type=&quot;button&quot; class=&quot;RoleOfadd btn-small btn-primary&quot; style=&quot;margin-right:15px;&quot;&gt;&lt;i class=&quot;fa fa-plus&quot; &gt;&lt;/i&gt;&amp;nbsp;新增&lt;/button&gt;&apos;, &apos;&lt;button type=&quot;button&quot; class=&quot;RoleOfedit btn-small btn-primary&quot; style=&quot;margin-right:15px;&quot;&gt;&lt;i class=&quot;fa fa-pencil-square-o&quot; &gt;&lt;/i&gt;&amp;nbsp;修改&lt;/button&gt;&apos;, &apos;&lt;button type=&quot;button&quot; class=&quot;RoleOfdelete btn-small btn-primary&quot; style=&quot;margin-right:15px;&quot;&gt;&lt;i class=&quot;fa fa-trash-o&quot; &gt;&lt;/i&gt;&amp;nbsp;删除&lt;/button&gt;&apos; ].join(&apos;&apos;); } // 格式化类型 function typeFormatter(value, row, index) { if (value === &apos;menu&apos;) { return &apos;菜单&apos;; } if (value === &apos;button&apos;) { return &apos;按钮&apos;; } if (value === &apos;api&apos;) { return &apos;接口&apos;; } return &apos;-&apos;; } // 格式化状态 function statusFormatter(value, row, index) { if (value === 1) { return &apos;&lt;span class=&quot;label label-success&quot;&gt;正常&lt;/span&gt;&apos;; } else { return &apos;&lt;span class=&quot;label label-default&quot;&gt;锁定&lt;/span&gt;&apos;; } } //初始化操作按钮的方法 window.operateEvents = { &apos;click .RoleOfadd&apos;: function (e, value, row, index) { add(row.id); }, &apos;click .RoleOfdelete&apos;: function (e, value, row, index) { del(row.id); }, &apos;click .RoleOfedit&apos;: function (e, value, row, index) { update(row.id); } }; 选中方法 &lt;script&gt; /** * 选中父项时，同时选中子项 * @param datas 所有的数据 * @param row 当前数据 * @param id id 字段名 * @param pid 父id字段名 */ function selectChilds(datas,row,id,pid,checked) { for(var i in datas){ if(datas[i][pid] == row[id]){ datas[i].check=checked; selectChilds(datas,datas[i],id,pid,checked); }; } } function selectParentChecked(datas,row,id,pid){ for(var i in datas){ if(datas[i][id] == row[pid]){ datas[i].check=true; selectParentChecked(datas,datas[i],id,pid); }; } } function test() { var selRows = $table.bootstrapTable(&quot;getSelections&quot;); if(selRows.length == 0){ alert(&quot;请至少选择一行&quot;); return; } var postData = &quot;&quot;; $.each(selRows,function(i) { postData += this.id; if (i &lt; selRows.length - 1) { postData += &quot;， &quot;; } }); alert(&quot;你选中行的 id 为：&quot;+postData); } function add(id) { alert(&quot;add 方法 , id = &quot; + id); } function del(id) { alert(&quot;del 方法 , id = &quot; + id); } function update(id) { alert(&quot;update 方法 , id = &quot; + id); } &lt;/script&gt; 源码已上传百度云：https://pan.baidu.com/s/12GD-LloYGeCswF_nQifVaA 提取二维码]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>bootstrap-table + treegrid - bootstarp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据清洗工具kettle的下载与简单的使用]]></title>
    <url>%2F2018%2F11%2F28%2Fkettle-1%2F</url>
    <content type="text"><![CDATA[1、下载 https://community.hitachivantara.com/docs/DOC-1009855找到这个downloads，可以根据自己下载，我用的是6.0.1.0-3的版本 2、安装的话看自己的磁盘，安装好是这个样子这个Spoon.bat批处理文件就是windows环境启动程序，Spoon.sh是在Linux、AppleOSX、Solaris平台上运行的启动程序 3、启动环境环境就是java的jdk配置环境，jdk 1.5以上就行 ，如何配置jdk就不多说了，可以自己到网上百度4、启动 5、写demo以oracle数据库为例 ceshi数据表结构和表数据 ceshi2数据表结构和表数据 开始写demo，在kettle中双击“转换”或者点“文件–&gt;新建–&gt;转换”或者点击左上角的“+” 打开输入选项，选择表输入，打开输出选项，选择插入/更新（双击或者拖进页面都可以） 把表输入和插入/更新连接起来（选中表输入+shift键，指向插入/更新；或者把鼠标放在表输入上，出现如下图标，选择又箭头） 双击表输入图标，进入表输入 连接之前先把你要链接的数据库的驱动放进kettle的lib目录下 新建链接 测试链接 书写sql，查数据（写完sql可以点击“预览”，看是否是自己想要的数据） 双击插入/更新 新建链接和上一步一样 目标表就是你要把数据导入那个表中 提交记录数量：数据量大的话写1000，数据量小的话默认100就好 用来查询的关键字：点击获取字段获取上一步的字段 更新的字段就是数据更新到那个表的字段 运行 点击倒三角开始运行 点击眼睛图案预览程序运行完成后的样子 图标右上角都有绿色的对号就是程序无误 查看数据 这个是我在网上荡的kettle用户手册链接：https://pan.baidu.com/s/1mGwSqXjZOmLW3Ngk86YHyA 提取码：eplo]]></content>
      <categories>
        <category>数据清洗</category>
      </categories>
      <tags>
        <tag>kettle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[word、excel、ppt转PDF文件]]></title>
    <url>%2F2018%2F11%2F15%2F%E6%96%87%E4%BB%B6%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[今天项目要求做个word、excel转pdf的功能，百般搜刮，测试，终于完成下面这个是word、excel、ppt转pdf功能，支持doc、docx、xls、xlsx、ppt、pptx转pdf1、 准备工作：windows环境、maven项目，普通项目也可以下载jacob.zip，地址：https://sourceforge.net/projects/jacob-project/ 2、 点击 download 就行，下载解压后显示的是 jacob-1.19文件 这个样子 3、 64位系统就用 x64的dll，32位系统就用x86的dll。将dll文件放入放入jdk/bin目录下,如下图所示： 4、 将压缩包中的jacob.jar引入项目 com.google.guava guava 19.0 &lt;dependency&gt; &lt;groupId&gt;com.jacob&lt;/groupId&gt; &lt;artifactId&gt;jacob&lt;/artifactId&gt; &lt;version&gt;1.18-M2&lt;/version&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt;D:\Maven\maven-repository\jacob\jacob.jar&lt;/systemPath&gt; &lt;/dependency&gt; 5、 展示代码import com.jacob.activeX.ActiveXComponent; import com.jacob.com.ComThread; import com.jacob.com.Dispatch; import com.jacob.com.Variant; public class Demo { private static final Integer WORD_TO_PDF_OPERAND = 17; private static final Integer PPT_TO_PDF_OPERAND = 32; private static final Integer EXCEL_TO_PDF_OPERAND = 0; public void docToPdf(String srcFilePath, String pdfFilePath) throws Exception { ActiveXComponent app = null; Dispatch doc = null; try { ComThread.InitSTA(); app = new ActiveXComponent(&quot;Word.Application&quot;); app.setProperty(&quot;Visible&quot;, false); Dispatch docs = app.getProperty(&quot;Documents&quot;).toDispatch(); Object[] obj = new Object[]{ srcFilePath, new Variant(false), new Variant(false),//是否只读 new Variant(false), new Variant(&quot;pwd&quot;) }; doc = Dispatch.invoke(docs, &quot;Open&quot;, Dispatch.Method, obj, new int[1]).toDispatch(); // Dispatch.put(doc, &quot;Compatibility&quot;, false); //兼容性检查,为特定值false不正确 Dispatch.put(doc, &quot;RemovePersonalInformation&quot;, false); Dispatch.call(doc, &quot;ExportAsFixedFormat&quot;, pdfFilePath, WORD_TO_PDF_OPERAND); // word保存为pdf格式宏，值为17 }catch (Exception e) { e.printStackTrace(); throw e; } finally { if (doc != null) { Dispatch.call(doc, &quot;Close&quot;, false); } if (app != null) { app.invoke(&quot;Quit&quot;, 0); } ComThread.Release(); } } public void pptToPdf(String srcFilePath, String pdfFilePath) throws Exception { ActiveXComponent app = null; Dispatch ppt = null; try { ComThread.InitSTA(); app = new ActiveXComponent(&quot;PowerPoint.Application&quot;); Dispatch ppts = app.getProperty(&quot;Presentations&quot;).toDispatch(); /* * call * param 4: ReadOnly * param 5: Untitled指定文件是否有标题 * param 6: WithWindow指定文件是否可见 * */ ppt = Dispatch.call(ppts, &quot;Open&quot;, srcFilePath, true,true, false).toDispatch(); Dispatch.call(ppt, &quot;SaveAs&quot;, pdfFilePath, PPT_TO_PDF_OPERAND); // ppSaveAsPDF为特定值32 } catch (Exception e) { e.printStackTrace(); throw e; } finally { if (ppt != null) { Dispatch.call(ppt, &quot;Close&quot;); } if (app != null) { app.invoke(&quot;Quit&quot;); } ComThread.Release(); } } public void excelToPdf(String inFilePath, String outFilePath) throws Exception { ActiveXComponent ax = null; Dispatch excel = null; try { ComThread.InitSTA(); ax = new ActiveXComponent(&quot;Excel.Application&quot;); ax.setProperty(&quot;Visible&quot;, new Variant(false)); ax.setProperty(&quot;AutomationSecurity&quot;, new Variant(3)); // 禁用宏 Dispatch excels = ax.getProperty(&quot;Workbooks&quot;).toDispatch(); Object[] obj = new Object[]{ inFilePath, new Variant(false), new Variant(false) }; excel = Dispatch.invoke(excels, &quot;Open&quot;, Dispatch.Method, obj, new int[9]).toDispatch(); // 转换格式 Object[] obj2 = new Object[]{ new Variant(EXCEL_TO_PDF_OPERAND), // PDF格式=0 outFilePath, new Variant(0) //0=标准 (生成的PDF图片不会变模糊) ; 1=最小文件 }; Dispatch.invoke(excel, &quot;ExportAsFixedFormat&quot;, Dispatch.Method,obj2, new int[1]); } catch (Exception es) { es.printStackTrace(); throw es; } finally { if (excel != null) { Dispatch.call(excel, &quot;Close&quot;, new Variant(false)); } if (ax != null) { ax.invoke(&quot;Quit&quot;, new Variant[] {}); ax = null; } ComThread.Release(); } } public static void main(String[] args) throws Exception { String path = &quot;C:\\Users\\lihao\\Desktop\\&quot;; new Demo().docToPdf(path + &quot;实习报告.doc&quot;, path+ &quot;实习报告.pdf&quot;); } } 代码主要参考：https://www.cnblogs.com/xxyfhjl/p/6773786.html]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>文件转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[win10专业版激活办法]]></title>
    <url>%2F2018%2F11%2F14%2Fwin10%E4%B8%93%E4%B8%9A%E7%89%88%E6%BF%80%E6%B4%BB%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[2018win10专业版激活方法1、windows+x ==》选择命令提示符（管理员） 2、 在命令提示符中依次输入：slmgr.vbs /upk （此时弹出窗口显未“已成功卸载了产品密钥”） slmgr /ipk W269N-WFGWX-YVC9B-4J6C9-T83GX （弹出窗口提示：“成功的安装了产品密钥”） slmgr /skms zh.us.to （弹出窗口提示：“密钥管理服务计算机名成功的设置为 zh.us.to”） slmgr /ato （弹出窗口提示：“成功的激活了产品”） 3、查看激活时间：以上步骤即激活了win10系统了，如果需要查看一下此密钥的激活天数，可以输入以下命令：slmgr /xpr，回车键后，将弹出窗口，提示”批量激活的过期时间”。 当此激活操作过期后，我们只需要重新激活一次，即可再享受180天激活机会。 附参照地址：http://www.ylmfwin100.com/ylmf/8643.html]]></content>
      <categories>
        <category>win10</category>
      </categories>
      <tags>
        <tag>win10激活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis-plus 条件包装类使用工具 EntityWrapper]]></title>
    <url>%2F2018%2F11%2F08%2FMybatis-EntryWrapper%2F</url>
    <content type="text"><![CDATA[使用T selectOne(Wrapper wrapper);我们只需要传递入我们创建一个EntityWrapper()并将条件拼接好就可以。例如new EntityWrapper().eq(“id”,”1”)就是查询id等于1的这条数据。这里不仅仅支持eq(),还有like,not like ,group by等，差不多在SQL中需要的这里都有,可以自己慢慢发掘 上代码 List&lt;ApplyEntity&gt; list = devApplyService.selectList(new EntityWrapper&lt;ApplyEntity&gt;() .eq(&quot;code&quot;,code).eq(&quot;status&quot;,status).eq(&quot;orgid&quot;,orgid).isNotNull(&quot;auditresult&quot;)); Entity entity=sysDdService.selectOne(new EntityWrapper&lt;SysDdtEntity&gt;().eq(&quot;dict_type&quot;, &quot;CAR_AREA&quot;));]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Mybatis-EntityWrapper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[遍历Map的四种方法]]></title>
    <url>%2F2018%2F11%2F08%2Ffor-map%2F</url>
    <content type="text"><![CDATA[import java.util.HashMap; import java.util.Iterator; import java.util.Map; public class TestMap { public static void main(String[] args) { Map&lt;Integer, String&gt; map = new HashMap&lt;Integer, String&gt;(); map.put(1, &quot;a&quot;); map.put(2, &quot;b&quot;); map.put(3, &quot;ab&quot;); map.put(4, &quot;ab&quot;);// 和上面相同 ， 会自己筛选 System.out.println(map.size()); // 第一种： System.out.println(&quot;第一种：通过Map.keySet遍历key和value：&quot;); for (Integer in : map.keySet()) { //map.keySet()返回的是所有key的值 String str = map.get(in);//得到每个key多对用value的值 System.out.println(in + &quot; &quot; + str); } // 第二种： System.out.println(&quot;第二种：通过Map.entrySet使用iterator遍历key和value：&quot;); Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; it = map.entrySet().iterator(); while (it.hasNext()) { Map.Entry&lt;Integer, String&gt; entry = it.next(); System.out.println(&quot;key= &quot; + entry.getKey() + &quot; and value= &quot; + entry.getValue()); } // 第三种：推荐，尤其是容量大时 System.out.println(&quot;第三种：通过Map.entrySet遍历key和value&quot;); for (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) { //Map.entry&lt;Integer,String&gt; 映射项（键-值对） 有几个方法：用上面的名字entry //entry.getKey() ;entry.getValue(); entry.setValue(); //map.entrySet() 返回此映射中包含的映射关系的 Set视图。 System.out.println(&quot;key= &quot; + entry.getKey() + &quot; and value= &quot; + entry.getValue()); } // 第四种： System.out.println(&quot;第四种：通过Map.values()遍历所有的value，但不能遍历key&quot;); for (String v : map.values()) { System.out.println(&quot;value= &quot; + v); } } }]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Map遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[base64和图片的互相转换]]></title>
    <url>%2F2018%2F11%2F07%2Fbase64%2F</url>
    <content type="text"><![CDATA[今天刚把博客收拾好，迫不及待来发布一篇文章，有错误之处还请大神们指出来，上代码import java.io.ByteArrayOutputStream; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.net.HttpURLConnection; import java.net.URL; import com.steward.utils.StringUtil; import sun.misc.BASE64Decoder; import sun.misc.BASE64Encoder; @SuppressWarnings(&quot;restriction&quot;) public class Base64Utils { public static void main(String[] args) throws Exception { //本地图片地址 String url = &quot;C:/Users/Administrator/Desktop/628947887489084892.jpg&quot;; //在线图片地址 String string = &quot;http://bpic.588ku.com//element_origin_min_pic/17/03/03/7bf4480888f35addcf2ce942701c728a.jpg&quot;; String str = Base64Utils.ImageToBase64ByLocal(url); String ste = Base64Utils.ImageToBase64ByOnline(string); System.out.println(str); Base64Utils.Base64ToImage(str,&quot;C:/Users/Administrator/Desktop/test1.jpg&quot;); Base64Utils.Base64ToImage(ste, &quot;C:/Users/Administrator/Desktop/test2.jpg&quot;); } /** * 本地图片转换成base64字符串 * @param imgFile 图片本地路径 * @return * * @author ZHANGJL * @dateTime 2018-02-23 14:40:46 */ public static String ImageToBase64ByLocal(String imgFile) {// 将图片文件转化为字节数组字符串，并对其进行Base64编码处理 InputStream in = null; byte[] data = null; // 读取图片字节数组 try { in = new FileInputStream(imgFile); data = new byte[in.available()]; in.read(data); in.close(); } catch (IOException e) { e.printStackTrace(); } // 对字节数组Base64编码 BASE64Encoder encoder = new BASE64Encoder(); return encoder.encode(data);// 返回Base64编码过的字节数组字符串 } /** * 在线图片转换成base64字符串 * * @param imgURL 图片线上路径 * @return * * @author ZHANGJL * @dateTime 2018-02-23 14:43:18 */ public static String ImageToBase64ByOnline(String imgURL) { ByteArrayOutputStream data = new ByteArrayOutputStream(); try { // 创建URL URL url = new URL(imgURL); byte[] by = new byte[1024]; // 创建链接 HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.setRequestMethod(&quot;GET&quot;); conn.setConnectTimeout(5000); InputStream is = conn.getInputStream(); // 将内容读取内存中 int len = -1; while ((len = is.read(by)) != -1) { data.write(by, 0, len); } // 关闭流 is.close(); } catch (IOException e) { e.printStackTrace(); } // 对字节数组Base64编码 BASE64Encoder encoder = new BASE64Encoder(); return encoder.encode(data.toByteArray()); } /** * base64字符串转换成图片 * @param imgStr base64字符串 * @param imgFilePath 图片存放路径 * @return * * @author ZHANGJL * @dateTime 2018-02-23 14:42:17 */ public static boolean Base64ToImage(String imgStr,String imgFilePath) { // 对字节数组字符串进行Base64解码并生成图片 if (StringUtil.isEmpty(imgStr)) // 图像数据为空 return false; BASE64Decoder decoder = new BASE64Decoder(); try { // Base64解码 byte[] b = decoder.decodeBuffer(imgStr); for (int i = 0; i &lt; b.length; ++i) { if (b[i] &lt; 0) {// 调整异常数据 b[i] += 256; } } OutputStream out = new FileOutputStream(imgFilePath); out.write(b); out.flush(); out.close(); return true; } catch (Exception e) { return false; } } }]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>图片和流@1</tag>
      </tags>
  </entry>
</search>
