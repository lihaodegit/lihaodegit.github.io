<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[数据清洗工具kettle的下载与简单的使用]]></title>
    <url>%2F2018%2F11%2F28%2Fkettle-1%2F</url>
    <content type="text"><![CDATA[#数据清洗工具kettle的下载与简单的使用# ##1、下载 https://community.hitachivantara.com/docs/DOC-1009855##找到这个downloads，可以根据自己下载，我用的是6.0.1.0-3的版本 ##2、安装的话看自己的磁盘，安装好是这个样子##这个Spoon.bat批处理文件就是windows环境启动程序，Spoon.sh是在Linux、AppleOSX、Solaris平台上运行的启动程序 ##3、启动环境## 环境就是java的jdk配置环境，jdk 1.5以上就行 ，如何配置jdk就不多说了，可以自己到网上百度##4、启动## ##5、写demo##以oracle数据库为例 ceshi数据表结构和表数据 ceshi2数据表结构和表数据 开始写demo，在kettle中双击“转换”或者点“文件–&gt;新建–&gt;转换”或者点击左上角的“+” 打开输入选项，选择表输入，打开输出选项，选择插入/更新（双击或者拖进页面都可以） 把表输入和插入/更新连接起来（选中表输入+shift键，指向插入/更新；或者把鼠标放在表输入上，出现如下图标，选择又箭头） 双击表输入图标，进入表输入 连接之前先把你要链接的数据库的驱动放进kettle的lib目录下 新建链接 测试链接 书写sql，查数据（写完sql可以点击“预览”，看是否是自己想要的数据） 双击插入/更新 新建链接和上一步一样 目标表就是你要把数据导入那个表中 提交记录数量：数据量大的话写1000，数据量小的话默认100就好 用来查询的关键字：点击获取字段获取上一步的字段 更新的字段就是数据更新到那个表的字段 运行 点击倒三角开始运行 点击眼睛图案预览程序运行完成后的样子 图标右上角都有绿色的对号就是程序无误 查看数据]]></content>
      <categories>
        <category>数据清洗</category>
      </categories>
      <tags>
        <tag>kettle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[word、excel、ppt转PDF文件]]></title>
    <url>%2F2018%2F11%2F15%2F%E6%96%87%E4%BB%B6%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[今天项目要求做个word、excel转pdf的功能，百般搜刮，测试，终于完成下面这个是word、excel、ppt转pdf功能，支持doc、docx、xls、xlsx、ppt、pptx转pdf1、 准备工作：windows环境、maven项目，普通项目也可以下载jacob.zip，地址：https://sourceforge.net/projects/jacob-project/ 2、 点击 download 就行，下载解压后显示的是 jacob-1.19文件 这个样子 3、 64位系统就用 x64的dll，32位系统就用x86的dll。将dll文件放入放入jdk/bin目录下,如下图所示： 4、 将压缩包中的jacob.jar引入项目 com.google.guava guava 19.0 &lt;dependency&gt; &lt;groupId&gt;com.jacob&lt;/groupId&gt; &lt;artifactId&gt;jacob&lt;/artifactId&gt; &lt;version&gt;1.18-M2&lt;/version&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt;D:\Maven\maven-repository\jacob\jacob.jar&lt;/systemPath&gt; &lt;/dependency&gt; 5、 展示代码import com.jacob.activeX.ActiveXComponent; import com.jacob.com.ComThread; import com.jacob.com.Dispatch; import com.jacob.com.Variant; public class Demo { private static final Integer WORD_TO_PDF_OPERAND = 17; private static final Integer PPT_TO_PDF_OPERAND = 32; private static final Integer EXCEL_TO_PDF_OPERAND = 0; public void docToPdf(String srcFilePath, String pdfFilePath) throws Exception { ActiveXComponent app = null; Dispatch doc = null; try { ComThread.InitSTA(); app = new ActiveXComponent(&quot;Word.Application&quot;); app.setProperty(&quot;Visible&quot;, false); Dispatch docs = app.getProperty(&quot;Documents&quot;).toDispatch(); Object[] obj = new Object[]{ srcFilePath, new Variant(false), new Variant(false),//是否只读 new Variant(false), new Variant(&quot;pwd&quot;) }; doc = Dispatch.invoke(docs, &quot;Open&quot;, Dispatch.Method, obj, new int[1]).toDispatch(); // Dispatch.put(doc, &quot;Compatibility&quot;, false); //兼容性检查,为特定值false不正确 Dispatch.put(doc, &quot;RemovePersonalInformation&quot;, false); Dispatch.call(doc, &quot;ExportAsFixedFormat&quot;, pdfFilePath, WORD_TO_PDF_OPERAND); // word保存为pdf格式宏，值为17 }catch (Exception e) { e.printStackTrace(); throw e; } finally { if (doc != null) { Dispatch.call(doc, &quot;Close&quot;, false); } if (app != null) { app.invoke(&quot;Quit&quot;, 0); } ComThread.Release(); } } public void pptToPdf(String srcFilePath, String pdfFilePath) throws Exception { ActiveXComponent app = null; Dispatch ppt = null; try { ComThread.InitSTA(); app = new ActiveXComponent(&quot;PowerPoint.Application&quot;); Dispatch ppts = app.getProperty(&quot;Presentations&quot;).toDispatch(); /* * call * param 4: ReadOnly * param 5: Untitled指定文件是否有标题 * param 6: WithWindow指定文件是否可见 * */ ppt = Dispatch.call(ppts, &quot;Open&quot;, srcFilePath, true,true, false).toDispatch(); Dispatch.call(ppt, &quot;SaveAs&quot;, pdfFilePath, PPT_TO_PDF_OPERAND); // ppSaveAsPDF为特定值32 } catch (Exception e) { e.printStackTrace(); throw e; } finally { if (ppt != null) { Dispatch.call(ppt, &quot;Close&quot;); } if (app != null) { app.invoke(&quot;Quit&quot;); } ComThread.Release(); } } public void excelToPdf(String inFilePath, String outFilePath) throws Exception { ActiveXComponent ax = null; Dispatch excel = null; try { ComThread.InitSTA(); ax = new ActiveXComponent(&quot;Excel.Application&quot;); ax.setProperty(&quot;Visible&quot;, new Variant(false)); ax.setProperty(&quot;AutomationSecurity&quot;, new Variant(3)); // 禁用宏 Dispatch excels = ax.getProperty(&quot;Workbooks&quot;).toDispatch(); Object[] obj = new Object[]{ inFilePath, new Variant(false), new Variant(false) }; excel = Dispatch.invoke(excels, &quot;Open&quot;, Dispatch.Method, obj, new int[9]).toDispatch(); // 转换格式 Object[] obj2 = new Object[]{ new Variant(EXCEL_TO_PDF_OPERAND), // PDF格式=0 outFilePath, new Variant(0) //0=标准 (生成的PDF图片不会变模糊) ; 1=最小文件 }; Dispatch.invoke(excel, &quot;ExportAsFixedFormat&quot;, Dispatch.Method,obj2, new int[1]); } catch (Exception es) { es.printStackTrace(); throw es; } finally { if (excel != null) { Dispatch.call(excel, &quot;Close&quot;, new Variant(false)); } if (ax != null) { ax.invoke(&quot;Quit&quot;, new Variant[] {}); ax = null; } ComThread.Release(); } } public static void main(String[] args) throws Exception { String path = &quot;C:\\Users\\lihao\\Desktop\\&quot;; new Demo().docToPdf(path + &quot;实习报告.doc&quot;, path+ &quot;实习报告.pdf&quot;); } } 代码主要参考：https://www.cnblogs.com/xxyfhjl/p/6773786.html]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>文件转换</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[win10专业版激活办法]]></title>
    <url>%2F2018%2F11%2F14%2Fwin10%E4%B8%93%E4%B8%9A%E7%89%88%E6%BF%80%E6%B4%BB%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[2018win10专业版激活方法1、windows+x ==》选择命令提示符（管理员） 2、 在命令提示符中依次输入：slmgr.vbs /upk （此时弹出窗口显未“已成功卸载了产品密钥”） slmgr /ipk W269N-WFGWX-YVC9B-4J6C9-T83GX （弹出窗口提示：“成功的安装了产品密钥”） slmgr /skms zh.us.to （弹出窗口提示：“密钥管理服务计算机名成功的设置为 zh.us.to”） slmgr /ato （弹出窗口提示：“成功的激活了产品”） 3、查看激活时间：以上步骤即激活了win10系统了，如果需要查看一下此密钥的激活天数，可以输入以下命令：slmgr /xpr，回车键后，将弹出窗口，提示”批量激活的过期时间”。 当此激活操作过期后，我们只需要重新激活一次，即可再享受180天激活机会。 附参照地址：http://www.ylmfwin100.com/ylmf/8643.html]]></content>
      <categories>
        <category>win10</category>
      </categories>
      <tags>
        <tag>win10激活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis-plus 条件包装类使用工具 EntityWrapper]]></title>
    <url>%2F2018%2F11%2F08%2FMybatis-EntryWrapper%2F</url>
    <content type="text"><![CDATA[使用T selectOne(Wrapper wrapper);我们只需要传递入我们创建一个EntityWrapper()并将条件拼接好就可以。例如new EntityWrapper().eq(“id”,”1”)就是查询id等于1的这条数据。这里不仅仅支持eq(),还有like,not like ,group by等，差不多在SQL中需要的这里都有,可以自己慢慢发掘 上代码 List&lt;ApplyEntity&gt; list = devApplyService.selectList(new EntityWrapper&lt;ApplyEntity&gt;() .eq(&quot;code&quot;,code).eq(&quot;status&quot;,status).eq(&quot;orgid&quot;,orgid).isNotNull(&quot;auditresult&quot;)); Entity entity=sysDdService.selectOne(new EntityWrapper&lt;SysDdtEntity&gt;().eq(&quot;dict_type&quot;, &quot;CAR_AREA&quot;));]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Mybatis-EntityWrapper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[遍历Map的四种方法]]></title>
    <url>%2F2018%2F11%2F08%2Ffor-map%2F</url>
    <content type="text"><![CDATA[import java.util.HashMap; import java.util.Iterator; import java.util.Map; public class TestMap { public static void main(String[] args) { Map&lt;Integer, String&gt; map = new HashMap&lt;Integer, String&gt;(); map.put(1, &quot;a&quot;); map.put(2, &quot;b&quot;); map.put(3, &quot;ab&quot;); map.put(4, &quot;ab&quot;);// 和上面相同 ， 会自己筛选 System.out.println(map.size()); // 第一种： System.out.println(&quot;第一种：通过Map.keySet遍历key和value：&quot;); for (Integer in : map.keySet()) { //map.keySet()返回的是所有key的值 String str = map.get(in);//得到每个key多对用value的值 System.out.println(in + &quot; &quot; + str); } // 第二种： System.out.println(&quot;第二种：通过Map.entrySet使用iterator遍历key和value：&quot;); Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; it = map.entrySet().iterator(); while (it.hasNext()) { Map.Entry&lt;Integer, String&gt; entry = it.next(); System.out.println(&quot;key= &quot; + entry.getKey() + &quot; and value= &quot; + entry.getValue()); } // 第三种：推荐，尤其是容量大时 System.out.println(&quot;第三种：通过Map.entrySet遍历key和value&quot;); for (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) { //Map.entry&lt;Integer,String&gt; 映射项（键-值对） 有几个方法：用上面的名字entry //entry.getKey() ;entry.getValue(); entry.setValue(); //map.entrySet() 返回此映射中包含的映射关系的 Set视图。 System.out.println(&quot;key= &quot; + entry.getKey() + &quot; and value= &quot; + entry.getValue()); } // 第四种： System.out.println(&quot;第四种：通过Map.values()遍历所有的value，但不能遍历key&quot;); for (String v : map.values()) { System.out.println(&quot;value= &quot; + v); } } }]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Map遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[base64和图片的互相转换]]></title>
    <url>%2F2018%2F11%2F07%2Fbase64%2F</url>
    <content type="text"><![CDATA[今天刚把博客收拾好，迫不及待来发布一篇文章，有错误之处还请大神们指出来，上代码import java.io.ByteArrayOutputStream; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.net.HttpURLConnection; import java.net.URL; import com.steward.utils.StringUtil; import sun.misc.BASE64Decoder; import sun.misc.BASE64Encoder; @SuppressWarnings(&quot;restriction&quot;) public class Base64Utils { public static void main(String[] args) throws Exception { //本地图片地址 String url = &quot;C:/Users/Administrator/Desktop/628947887489084892.jpg&quot;; //在线图片地址 String string = &quot;http://bpic.588ku.com//element_origin_min_pic/17/03/03/7bf4480888f35addcf2ce942701c728a.jpg&quot;; String str = Base64Utils.ImageToBase64ByLocal(url); String ste = Base64Utils.ImageToBase64ByOnline(string); System.out.println(str); Base64Utils.Base64ToImage(str,&quot;C:/Users/Administrator/Desktop/test1.jpg&quot;); Base64Utils.Base64ToImage(ste, &quot;C:/Users/Administrator/Desktop/test2.jpg&quot;); } /** * 本地图片转换成base64字符串 * @param imgFile 图片本地路径 * @return * * @author ZHANGJL * @dateTime 2018-02-23 14:40:46 */ public static String ImageToBase64ByLocal(String imgFile) {// 将图片文件转化为字节数组字符串，并对其进行Base64编码处理 InputStream in = null; byte[] data = null; // 读取图片字节数组 try { in = new FileInputStream(imgFile); data = new byte[in.available()]; in.read(data); in.close(); } catch (IOException e) { e.printStackTrace(); } // 对字节数组Base64编码 BASE64Encoder encoder = new BASE64Encoder(); return encoder.encode(data);// 返回Base64编码过的字节数组字符串 } /** * 在线图片转换成base64字符串 * * @param imgURL 图片线上路径 * @return * * @author ZHANGJL * @dateTime 2018-02-23 14:43:18 */ public static String ImageToBase64ByOnline(String imgURL) { ByteArrayOutputStream data = new ByteArrayOutputStream(); try { // 创建URL URL url = new URL(imgURL); byte[] by = new byte[1024]; // 创建链接 HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.setRequestMethod(&quot;GET&quot;); conn.setConnectTimeout(5000); InputStream is = conn.getInputStream(); // 将内容读取内存中 int len = -1; while ((len = is.read(by)) != -1) { data.write(by, 0, len); } // 关闭流 is.close(); } catch (IOException e) { e.printStackTrace(); } // 对字节数组Base64编码 BASE64Encoder encoder = new BASE64Encoder(); return encoder.encode(data.toByteArray()); } /** * base64字符串转换成图片 * @param imgStr base64字符串 * @param imgFilePath 图片存放路径 * @return * * @author ZHANGJL * @dateTime 2018-02-23 14:42:17 */ public static boolean Base64ToImage(String imgStr,String imgFilePath) { // 对字节数组字符串进行Base64解码并生成图片 if (StringUtil.isEmpty(imgStr)) // 图像数据为空 return false; BASE64Decoder decoder = new BASE64Decoder(); try { // Base64解码 byte[] b = decoder.decodeBuffer(imgStr); for (int i = 0; i &lt; b.length; ++i) { if (b[i] &lt; 0) {// 调整异常数据 b[i] += 256; } } OutputStream out = new FileOutputStream(imgFilePath); out.write(b); out.flush(); out.close(); return true; } catch (Exception e) { return false; } } }]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>图片和流@1</tag>
      </tags>
  </entry>
</search>
