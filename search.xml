<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[mybatis-plus 使用工具 EntityWrapper]]></title>
    <url>%2F2018%2F11%2F08%2FMybatis-EntryWrapper%2F</url>
    <content type="text"><![CDATA[使用T selectOne(Wrapper wrapper);我们只需要传递入我们创建一个EntityWrapper()并将条件拼接好就可以。例如new EntityWrapper().eq(“id”,”1”)就是查询id等于1的这条数据。这里不仅仅支持eq(),还有like,not like ,group by等，差不多在SQL中需要的这里都有,可以自己慢慢发掘 上代码 List&lt;ApplyEntity&gt; list = devApplyService.selectList(new EntityWrapper&lt;ApplyEntity&gt;() .eq(&quot;code&quot;,code).eq(&quot;status&quot;,status).eq(&quot;orgid&quot;,orgid).isNotNull(&quot;auditresult&quot;)); Entity entity=sysDdService.selectOne(new EntityWrapper&lt;SysDdtEntity&gt;().eq(&quot;dict_type&quot;, &quot;CAR_AREA&quot;));]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Mybatis-EntityWrapper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[遍历Map的四种方法]]></title>
    <url>%2F2018%2F11%2F08%2Ffor-map%2F</url>
    <content type="text"><![CDATA[import java.util.HashMap; import java.util.Iterator; import java.util.Map; public class TestMap { public static void main(String[] args) { Map&lt;Integer, String&gt; map = new HashMap&lt;Integer, String&gt;(); map.put(1, &quot;a&quot;); map.put(2, &quot;b&quot;); map.put(3, &quot;ab&quot;); map.put(4, &quot;ab&quot;);// 和上面相同 ， 会自己筛选 System.out.println(map.size()); // 第一种： System.out.println(&quot;第一种：通过Map.keySet遍历key和value：&quot;); for (Integer in : map.keySet()) { //map.keySet()返回的是所有key的值 String str = map.get(in);//得到每个key多对用value的值 System.out.println(in + &quot; &quot; + str); } // 第二种： System.out.println(&quot;第二种：通过Map.entrySet使用iterator遍历key和value：&quot;); Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; it = map.entrySet().iterator(); while (it.hasNext()) { Map.Entry&lt;Integer, String&gt; entry = it.next(); System.out.println(&quot;key= &quot; + entry.getKey() + &quot; and value= &quot; + entry.getValue()); } // 第三种：推荐，尤其是容量大时 System.out.println(&quot;第三种：通过Map.entrySet遍历key和value&quot;); for (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) { //Map.entry&lt;Integer,String&gt; 映射项（键-值对） 有几个方法：用上面的名字entry //entry.getKey() ;entry.getValue(); entry.setValue(); //map.entrySet() 返回此映射中包含的映射关系的 Set视图。 System.out.println(&quot;key= &quot; + entry.getKey() + &quot; and value= &quot; + entry.getValue()); } // 第四种： System.out.println(&quot;第四种：通过Map.values()遍历所有的value，但不能遍历key&quot;); for (String v : map.values()) { System.out.println(&quot;value= &quot; + v); } } }]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>Map遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[base64和图片的互相转换]]></title>
    <url>%2F2018%2F11%2F07%2Fbase64%2F</url>
    <content type="text"><![CDATA[今天刚把博客收拾好，迫不及待来发布一篇文章，有错误之处还请大神们指出来，上代码import java.io.ByteArrayOutputStream; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.net.HttpURLConnection; import java.net.URL; import com.steward.utils.StringUtil; import sun.misc.BASE64Decoder; import sun.misc.BASE64Encoder; @SuppressWarnings(&quot;restriction&quot;) public class Base64Utils { public static void main(String[] args) throws Exception { //本地图片地址 String url = &quot;C:/Users/Administrator/Desktop/628947887489084892.jpg&quot;; //在线图片地址 String string = &quot;http://bpic.588ku.com//element_origin_min_pic/17/03/03/7bf4480888f35addcf2ce942701c728a.jpg&quot;; String str = Base64Utils.ImageToBase64ByLocal(url); String ste = Base64Utils.ImageToBase64ByOnline(string); System.out.println(str); Base64Utils.Base64ToImage(str,&quot;C:/Users/Administrator/Desktop/test1.jpg&quot;); Base64Utils.Base64ToImage(ste, &quot;C:/Users/Administrator/Desktop/test2.jpg&quot;); } /** * 本地图片转换成base64字符串 * @param imgFile 图片本地路径 * @return * * @author ZHANGJL * @dateTime 2018-02-23 14:40:46 */ public static String ImageToBase64ByLocal(String imgFile) {// 将图片文件转化为字节数组字符串，并对其进行Base64编码处理 InputStream in = null; byte[] data = null; // 读取图片字节数组 try { in = new FileInputStream(imgFile); data = new byte[in.available()]; in.read(data); in.close(); } catch (IOException e) { e.printStackTrace(); } // 对字节数组Base64编码 BASE64Encoder encoder = new BASE64Encoder(); return encoder.encode(data);// 返回Base64编码过的字节数组字符串 } /** * 在线图片转换成base64字符串 * * @param imgURL 图片线上路径 * @return * * @author ZHANGJL * @dateTime 2018-02-23 14:43:18 */ public static String ImageToBase64ByOnline(String imgURL) { ByteArrayOutputStream data = new ByteArrayOutputStream(); try { // 创建URL URL url = new URL(imgURL); byte[] by = new byte[1024]; // 创建链接 HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.setRequestMethod(&quot;GET&quot;); conn.setConnectTimeout(5000); InputStream is = conn.getInputStream(); // 将内容读取内存中 int len = -1; while ((len = is.read(by)) != -1) { data.write(by, 0, len); } // 关闭流 is.close(); } catch (IOException e) { e.printStackTrace(); } // 对字节数组Base64编码 BASE64Encoder encoder = new BASE64Encoder(); return encoder.encode(data.toByteArray()); } /** * base64字符串转换成图片 * @param imgStr base64字符串 * @param imgFilePath 图片存放路径 * @return * * @author ZHANGJL * @dateTime 2018-02-23 14:42:17 */ public static boolean Base64ToImage(String imgStr,String imgFilePath) { // 对字节数组字符串进行Base64解码并生成图片 if (StringUtil.isEmpty(imgStr)) // 图像数据为空 return false; BASE64Decoder decoder = new BASE64Decoder(); try { // Base64解码 byte[] b = decoder.decodeBuffer(imgStr); for (int i = 0; i &lt; b.length; ++i) { if (b[i] &lt; 0) {// 调整异常数据 b[i] += 256; } } OutputStream out = new FileOutputStream(imgFilePath); out.write(b); out.flush(); out.close(); return true; } catch (Exception e) { return false; } } }]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>图片和流@1</tag>
      </tags>
  </entry>
</search>
